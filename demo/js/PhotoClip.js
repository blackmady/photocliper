/*!
 * PhotoClip - 一款手势驱动的裁图插件
 * @version v3.4.7
 * @author arcoon
 * @license MIT
 * 
 * git - https://github.com/baijunjie/PhotoClip.js.git
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("PhotoClip", [], factory);
	else if(typeof exports === 'object')
		exports["PhotoClip"] = factory();
	else
		root["PhotoClip"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(1), __webpack_require__(2), __webpack_require__(3), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _hammerjs, _iscroll, _lrz, utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _hammerjs = _interopRequireDefault(_hammerjs);
  _iscroll = _interopRequireDefault(_iscroll);
  _lrz = _interopRequireDefault(_lrz);
  utils = _interopRequireWildcard(utils);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var is_mobile = !!navigator.userAgent.match(/mobile/i),
      is_android = !!navigator.userAgent.match(/android/i),
      // 测试浏览器是否支持 Transition 动画，以及支持的前缀
  supportTransition = (0, utils.support)('transition'),
      prefix = (0, utils.support)('transform'),
      noop = function noop() {};

  var defaultOptions = {
    size: [100, 100],
    adaptive: '',
    outputSize: [0, 0],
    outputType: 'jpg',
    outputQuality: .8,
    maxZoom: 1,
    rotateFree: !is_android,
    view: '',
    file: '',
    ok: '',
    img: '',
    loadStart: noop,
    loadComplete: noop,
    loadError: noop,
    done: noop,
    fail: noop,
    lrzOption: {
      width: is_android ? 1000 : undefined,
      height: is_android ? 1000 : undefined,
      quality: .7
    },
    style: {
      maskColor: 'rgba(0,0,0,.5)',
      maskBorder: '2px dashed #ddd',
      jpgFillColor: '#fff'
    },
    errorMsg: {
      noSupport: '您的浏览器版本过于陈旧，无法支持裁图功能，请更换新的浏览器！',
      imgError: '不支持该图片格式，请选择常规格式的图片文件！',
      imgHandleError: '图片处理失败！请更换其它图片尝试。',
      imgLoadError: '图片读取失败！请更换其它图片尝试。',
      noImg: '没有可裁剪的图片！',
      clipError: '截图失败！当前图片源文件可能存在跨域问题，请确保图片与应用同源。如果您是在本地环境下执行本程序，请更换至服务器环境。'
    }
  };

  var PhotoClip =
  /*#__PURE__*/
  function () {
    function PhotoClip(container, options) {
      _classCallCheck(this, PhotoClip);

      container = (0, utils.$)(container); // 获取容器

      if (container && container.length) {
        this._$container = container[0];
      } else {
        return;
      }

      this._options = (0, utils.extend)(true, {}, defaultOptions, options);

      if (prefix === undefined) {
        this._options.errorMsg.noSupport && alert(this._options.errorMsg.noSupport);
      }

      this._init();
    }

    _createClass(PhotoClip, [{
      key: "_init",
      value: function _init() {
        var _this = this;

        var options = this._options; // options 预设

        if ((0, utils.isNumber)(options.size)) {
          options.size = [options.size, options.size];
        } else if ((0, utils.isArray)(options.size)) {
          if (!(0, utils.isNumber)(options.size[0]) || options.size[0] <= 0) options.size[0] = defaultOptions.size[0];
          if (!(0, utils.isNumber)(options.size[1]) || options.size[1] <= 0) options.size[1] = defaultOptions.size[1];
        } else {
          options.size = (0, utils.extend)({}, defaultOptions.size);
        }

        if ((0, utils.isNumber)(options.outputSize)) {
          options.outputSize = [options.outputSize, 0];
        } else if ((0, utils.isArray)(options.outputSize)) {
          if (!(0, utils.isNumber)(options.outputSize[0]) || options.outputSize[0] < 0) options.outputSize[0] = defaultOptions.outputSize[0];
          if (!(0, utils.isNumber)(options.outputSize[1]) || options.outputSize[1] < 0) options.outputSize[1] = defaultOptions.outputSize[1];
        } else {
          options.outputSize = (0, utils.extend)({}, defaultOptions.outputSize);
        }

        if (options.outputType === 'jpg') {
          options.outputType = 'image/jpeg';
        } else {
          // 如果不是 jpg，则全部按 png 来对待
          options.outputType = 'image/png';
        } // 变量初始化


        if ((0, utils.isArray)(options.adaptive)) {
          this._widthIsPercent = options.adaptive[0] && (0, utils.isPercent)(options.adaptive[0]) ? options.adaptive[0] : false;
          this._heightIsPercent = options.adaptive[1] && (0, utils.isPercent)(options.adaptive[1]) ? options.adaptive[1] : false;
        }

        this._outputWidth = options.outputSize[0];
        this._outputHeight = options.outputSize[1];
        this._canvas = document.createElement('canvas'); // 图片裁剪用到的画布

        this._iScroll = null; // 图片的scroll对象，包含图片的位置与缩放信息

        this._hammerManager = null; // hammer 管理对象

        this._clipWidth = 0;
        this._clipHeight = 0;
        this._clipSizeRatio = 1; // 截取框宽高比

        this._$img = null; // 图片的DOM对象

        this._imgLoaded = false; // 图片是否已经加载完成

        this._containerWidth = 0;
        this._containerHeight = 0;
        this._viewList = null; // 最终截图后呈现的视图容器的DOM数组

        this._fileList = null; // file 控件的DOM数组

        this._okList = null; // 截图按钮的DOM数组

        this._$mask = null;
        this._$mask_left = null;
        this._$mask_right = null;
        this._$mask_right = null;
        this._$mask_bottom = null;
        this._$clip_frame = null;
        this._$clipLayer = null; // 裁剪层，包含移动层

        this._$moveLayer = null; // 移动层，包含旋转层

        this._$rotateLayer = null; // 旋转层

        this._moveLayerWidth = 0; // 移动层的宽度(不跟随scale发生变化)

        this._moveLayerHeight = 0; // 移动层的高度(不跟随scale发生变化)

        this._moveLayerPaddingLeft = 0; // 当图片宽度小于裁剪框宽度时，移动层的补偿左边距(不跟随scale发生变化)

        this._moveLayerPaddingTop = 0; // 当图片高度小于裁剪框高度时，移动层的补偿顶边距(不跟随scale发生变化)

        this._atRotation = false; // 旋转层是否正在旋转中

        this._rotateLayerWidth = 0; // 旋转层所呈现矩形的宽度(不跟随scale发生变化)

        this._rotateLayerHeight = 0; // 旋转层所呈现矩形的高度(不跟随scale发生变化)

        this._rotateLayerX = 0; // 旋转层的当前X坐标(不跟随scale发生变化)

        this._rotateLayerY = 0; // 旋转层的当前Y坐标(不跟随scale发生变化)

        this._rotateLayerOriginX = 0; // 旋转层的旋转参考点X(不跟随scale发生变化)

        this._rotateLayerOriginY = 0; // 旋转层的旋转参考点Y(不跟随scale发生变化)

        this._curAngle = 0; // 旋转层的当前角度

        (0, utils.bind)(this, '_resetScroll', '_rotateCW90', '_fileOnChangeHandle', '_clipImg', '_resize', 'size', 'load', 'clear', 'rotate', 'scale', 'clip', 'destroy');

        this._initElements();

        this._initScroll();

        this._initRotationEvent();

        this._initFile();

        this._resize();

        window.addEventListener('resize', this._resize);

        if (this._okList = (0, utils.$)(options.ok)) {
          this._okList.forEach(function ($ok) {
            $ok.addEventListener('click', _this._clipImg);
          });
        }

        if (this._options.img) {
          this._lrzHandle(this._options.img);
        }
      }
    }, {
      key: "_initElements",
      value: function _initElements() {
        // 初始化容器
        var $container = this._$container,
            style = $container.style,
            containerOriginStyle = {};
        containerOriginStyle['user-select'] = style['user-select'];
        containerOriginStyle['overflow'] = style['overflow'];
        containerOriginStyle['position'] = style['position'];
        this._containerOriginStyle = containerOriginStyle;
        (0, utils.css)($container, {
          'user-select': 'none',
          'overflow': 'hidden'
        });

        if ((0, utils.css)($container, 'position') === 'static') {
          (0, utils.css)($container, 'position', 'relative');
        } // 创建裁剪层


        this._$clipLayer = (0, utils.createElement)($container, 'photo-clip-layer', {
          'position': 'absolute',
          'left': '50%',
          'top': '50%'
        });
        this._$moveLayer = (0, utils.createElement)(this._$clipLayer, 'photo-clip-move-layer');
        this._$rotateLayer = (0, utils.createElement)(this._$moveLayer, 'photo-clip-rotate-layer'); // 创建遮罩

        var $mask = this._$mask = (0, utils.createElement)($container, 'photo-clip-mask', {
          'position': 'absolute',
          'left': 0,
          'top': 0,
          'width': '100%',
          'height': '100%',
          'pointer-events': 'none'
        });
        var options = this._options,
            maskColor = options.style.maskColor,
            maskBorder = options.style.maskBorder;
        this._$mask_left = (0, utils.createElement)($mask, 'photo-clip-mask-left', {
          'position': 'absolute',
          'left': 0,
          'right': '50%',
          'top': '50%',
          'bottom': '50%',
          'width': 'auto',
          'background-color': maskColor
        });
        this._$mask_right = (0, utils.createElement)($mask, 'photo-clip-mask-right', {
          'position': 'absolute',
          'left': '50%',
          'right': 0,
          'top': '50%',
          'bottom': '50%',
          'background-color': maskColor
        });
        this._$mask_top = (0, utils.createElement)($mask, 'photo-clip-mask-top', {
          'position': 'absolute',
          'left': 0,
          'right': 0,
          'top': 0,
          'bottom': '50%',
          'background-color': maskColor
        });
        this._$mask_bottom = (0, utils.createElement)($mask, 'photo-clip-mask-bottom', {
          'position': 'absolute',
          'left': 0,
          'right': 0,
          'top': '50%',
          'bottom': 0,
          'background-color': maskColor
        }); // 创建截取框

        this._$clip_frame = (0, utils.createElement)($mask, 'photo-clip-area', {
          'border': maskBorder,
          'position': 'absolute',
          'left': '50%',
          'top': '50%'
        }); // 初始化视图容器

        this._viewList = (0, utils.$)(options.view);

        if (this._viewList) {
          var viewOriginStyleList = [];

          this._viewList.forEach(function ($view, i) {
            var style = $view.style,
                viewOriginStyle = {};
            viewOriginStyle['background-repeat'] = style['background-repeat'];
            viewOriginStyle['background-position'] = style['background-position'];
            viewOriginStyle['background-size'] = style['background-size'];
            viewOriginStyleList[i] = viewOriginStyle;
            (0, utils.css)($view, {
              'background-repeat': 'no-repeat',
              'background-position': 'center',
              'background-size': 'contain'
            });
          });

          this._viewOriginStyleList = viewOriginStyleList;
        }
      }
    }, {
      key: "_initScroll",
      value: function _initScroll() {
        var _this2 = this;

        this._iScroll = new _iscroll["default"](this._$clipLayer, {
          zoom: true,
          scrollX: true,
          scrollY: true,
          freeScroll: true,
          mouseWheel: true,
          disablePointer: true,
          // important to disable the pointer events that causes the issues
          disableTouch: false,
          // false if you want the slider to be usable with touch devices
          disableMouse: false,
          // false if you want the slider to be usable with a mouse (desktop)
          wheelAction: 'zoom',
          bounceTime: 300
        });

        this._iScroll.on('zoomEnd', function () {
          _this2._calcScale();

          _this2._resizeMoveLayer();

          _this2._refreshScroll();
        });
      } // 重置 iScroll

    }, {
      key: "_resetScroll",
      value: function _resetScroll() {
        var iScroll = this._iScroll;

        this._calcScale();

        var scale = iScroll.scale = iScroll.options.startZoom;

        this._resizeMoveLayer(); // 重置旋转层


        this._rotateLayerX = 0;
        this._rotateLayerY = 0;
        this._curAngle = 0;
        setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, this._curAngle); // 初始化居中

        iScroll.scrollTo((this._clipWidth - this._moveLayerWidth * scale) * .5, (this._clipHeight - this._moveLayerHeight * scale) * .5);

        this._refreshScroll();
      } // 刷新 iScroll
      // duration 表示移动层超出容器时的复位动画持续时长

    }, {
      key: "_refreshScroll",
      value: function _refreshScroll(duration) {
        duration = duration || 0;
        var iScroll = this._iScroll,
            scale = iScroll.scale,
            iScrollOptions = iScroll.options;
        var lastScale = Math.max(iScrollOptions.zoomMin, Math.min(iScrollOptions.zoomMax, scale));

        if (lastScale !== scale) {
          iScroll.zoom(lastScale, undefined, undefined, duration);
        }

        iScroll.refresh(duration);
      } // 调整移动层

    }, {
      key: "_resizeMoveLayer",
      value: function _resizeMoveLayer() {
        var iScroll = this._iScroll,
            iScrollOptions = iScroll.options,
            scale = Math.max(iScrollOptions.zoomMin, Math.min(iScrollOptions.zoomMax, iScroll.scale));
        var width = this._rotateLayerWidth,
            height = this._rotateLayerHeight,
            clipWidth = this._clipWidth / scale,
            clipHeight = this._clipHeight / scale,
            ltClipArea = false;

        if (clipWidth > width) {
          ltClipArea = true;
          var offset = clipWidth - width;
          width += offset * 2;
          iScroll.x += (this._moveLayerPaddingLeft - offset) * scale;
          this._moveLayerPaddingLeft = offset;
        } else {
          this._moveLayerPaddingLeft = 0;
        }

        if (clipHeight > height) {
          ltClipArea = true;

          var _offset = clipHeight - height;

          height += _offset * 2;
          iScroll.y += (this._moveLayerPaddingTop - _offset) * scale;
          this._moveLayerPaddingTop = _offset;
        } else {
          this._moveLayerPaddingTop = 0;
        }

        if (ltClipArea) {
          setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, this._curAngle);
          iScroll.scrollTo(iScroll.x, iScroll.y);
        }

        if (this._moveLayerWidth === width && this._moveLayerHeight === height) return;
        this._moveLayerWidth = width;
        this._moveLayerHeight = height;
        (0, utils.css)(this._$moveLayer, {
          'width': width,
          'height': height
        }); // 在移动设备上，尤其是Android设备，当为一个元素重置了宽高时
        // 该元素的 offsetWidth/offsetHeight、clientWidth/clientHeight 等属性并不会立即更新，导致相关的js程序出现错误
        // iscroll 在刷新方法中正是使用了 offsetWidth/offsetHeight 来获取scroller元素($moveLayer)的宽高
        // 因此需要手动将元素重新添加进文档，迫使浏览器强制更新元素的宽高

        this._$clipLayer.appendChild(this._$moveLayer);
      }
    }, {
      key: "_calcScale",
      value: function _calcScale() {
        var iScroll = this._iScroll,
            iScrollOptions = iScroll.options,
            width = this._rotateLayerWidth,
            height = this._rotateLayerHeight,
            maxZoom = this._options.maxZoom;

        if (width && height) {
          iScrollOptions.zoomMin = 0.01; // iScrollOptions.zoomMin = Math.min(1, utils.getScale(this._clipWidth, this._clipHeight, width, height));

          iScrollOptions.zoomMax = maxZoom;
          iScrollOptions.startZoom = Math.min(maxZoom, utils.getScale(this._containerWidth, this._containerHeight, width, height));
        } else {
          iScrollOptions.zoomMin = 1;
          iScrollOptions.zoomMax = 1;
          iScrollOptions.startZoom = 1;
        } // console.log('zoomMin', iScrollOptions.zoomMin);
        // console.log('zoomMax', iScrollOptions.zoomMax);
        // console.log('startZoom', iScrollOptions.startZoom);

      }
    }, {
      key: "_initRotationEvent",
      value: function _initRotationEvent() {
        var _this3 = this;

        if (is_mobile) {
          this._hammerManager = new _hammerjs["default"].Manager(this._$moveLayer);

          this._hammerManager.add(new _hammerjs["default"].Rotate());

          var rotateFree = this._options.rotateFree,
              bounceTime = this._iScroll.options.bounceTime;
          var startTouch, startAngle, curAngle;

          this._hammerManager.on('rotatestart', function (e) {
            if (_this3._atRotation) return;
            startTouch = true;

            if (rotateFree) {
              startAngle = (e.rotation - _this3._curAngle) % 360;

              _this3._rotateLayerRotateReady(e.center);
            } else {
              startAngle = e.rotation;
            }
          });

          this._hammerManager.on('rotatemove', function (e) {
            if (!startTouch) return;
            curAngle = e.rotation - startAngle;
            rotateFree && _this3._rotateLayerRotate(curAngle);
          });

          this._hammerManager.on('rotateend rotatecancel', function (e) {
            if (!startTouch) return;
            startTouch = false;

            if (!rotateFree) {
              curAngle %= 360;
              if (curAngle > 180) curAngle -= 360;else if (curAngle < -180) curAngle += 360;

              if (curAngle > 30) {
                _this3._rotateBy(90, bounceTime, e.center);
              } else if (curAngle < -30) {
                _this3._rotateBy(-90, bounceTime, e.center);
              }

              return;
            } // 接近整90度方向时，进行校正


            var angle = curAngle % 360;
            if (angle < 0) angle += 360;

            if (angle < 10) {
              curAngle += -angle;
            } else if (angle > 80 && angle < 100) {
              curAngle += 90 - angle;
            } else if (angle > 170 && angle < 190) {
              curAngle += 180 - angle;
            } else if (angle > 260 && angle < 280) {
              curAngle += 270 - angle;
            } else if (angle > 350) {
              curAngle += 360 - angle;
            }

            _this3._rotateLayerRotateFinish(curAngle, bounceTime);
          });
        } else {
          this._$moveLayer.addEventListener('dblclick', this._rotateCW90);
        }
      }
    }, {
      key: "_rotateCW90",
      value: function _rotateCW90(e) {
        this._rotateBy(90, this._iScroll.options.bounceTime, {
          x: e.clientX,
          y: e.clientY
        });
      }
    }, {
      key: "_rotateBy",
      value: function _rotateBy(angle, duration, center) {
        this._rotateTo(this._curAngle + angle, duration, center);
      }
    }, {
      key: "_rotateTo",
      value: function _rotateTo(angle, duration, center) {
        if (this._atRotation) return;

        this._rotateLayerRotateReady(center); // 旋转层旋转结束


        this._rotateLayerRotateFinish(angle, duration);
      } // 旋转层旋转准备

    }, {
      key: "_rotateLayerRotateReady",
      value: function _rotateLayerRotateReady(center) {
        var scale = this._iScroll.scale;
        var coord; // 旋转参考点在移动层中的坐标

        if (!center) {
          coord = utils.loaclToLoacl(this._$moveLayer, this._$clipLayer, this._clipWidth * .5, this._clipHeight * .5);
        } else {
          coord = utils.globalToLoacl(this._$moveLayer, center.x, center.y);
        } // 由于得到的坐标是在缩放后坐标系上的坐标，因此需要除以缩放比例


        coord.x /= scale;
        coord.y /= scale; // 旋转参考点相对于旋转层零位（旋转层旋转前左上角）的坐标

        var coordBy0 = {
          x: coord.x - (this._rotateLayerX + this._moveLayerPaddingLeft),
          y: coord.y - (this._rotateLayerY + this._moveLayerPaddingTop)
        }; // 求出旋转层旋转前的旋转参考点
        // 这个参考点就是旋转中心点映射在旋转层图片上的坐标
        // 这个位置表示旋转层旋转前，该点所对应的坐标

        var origin = utils.pointRotate(coordBy0, -this._curAngle);
        this._rotateLayerOriginX = origin.x;
        this._rotateLayerOriginY = origin.y; // 设置参考点，算出新参考点作用下的旋转层位移，然后进行补差

        var rect = this._$rotateLayer.getBoundingClientRect();

        setOrigin(this._$rotateLayer, this._rotateLayerOriginX, this._rotateLayerOriginY);

        var newRect = this._$rotateLayer.getBoundingClientRect();

        this._rotateLayerX += (rect.left - newRect.left) / scale;
        this._rotateLayerY += (rect.top - newRect.top) / scale;
        setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, this._curAngle);
      } // 旋转层旋转

    }, {
      key: "_rotateLayerRotate",
      value: function _rotateLayerRotate(angle) {
        setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, angle);
        this._curAngle = angle;
      } // 旋转层旋转结束

    }, {
      key: "_rotateLayerRotateFinish",
      value: function _rotateLayerRotateFinish(angle, duration) {
        var _this4 = this;

        setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, angle);
        var iScroll = this._iScroll,
            scale = iScroll.scale,
            iScrollOptions = iScroll.options; // 获取旋转后的矩形

        var rect = this._$rotateLayer.getBoundingClientRect(); // 更新旋转层当前所呈现矩形的宽高


        this._rotateLayerWidth = rect.width / scale;
        this._rotateLayerHeight = rect.height / scale; // 当参考点为零时，获取位移后的矩形

        setOrigin(this._$rotateLayer, 0, 0);

        var rectByOrigin0 = this._$rotateLayer.getBoundingClientRect(); // 获取旋转前（零度）的矩形


        setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, 0);

        var rectByAngle0 = this._$rotateLayer.getBoundingClientRect(); // 当参考点为零时，旋转层旋转后，在形成的新矩形中，旋转层零位（旋转层旋转前左上角）的新坐标


        this._rotateLayerX = (rectByAngle0.left - rectByOrigin0.left) / scale;
        this._rotateLayerY = (rectByAngle0.top - rectByOrigin0.top) / scale;

        this._calcScale();

        this._resizeMoveLayer(); // 获取移动层的矩形


        var moveLayerRect = this._$moveLayer.getBoundingClientRect(); // 求出移动层与旋转层之间的位置偏移
        // 由于直接应用在移动层，因此不需要根据缩放换算
        // 注意，这里的偏移有可能还包含缩放过量时多出来的偏移


        var offset = {
          x: rect.left - this._moveLayerPaddingLeft * scale - moveLayerRect.left,
          y: rect.top - this._moveLayerPaddingTop * scale - moveLayerRect.top
        };
        iScroll.scrollTo(iScroll.x + offset.x, iScroll.y + offset.y);

        this._refreshScroll(iScroll.options.bounceTime); // 由于 offset 可能还包含缩放过量时多出来的偏移
        // 因此，这里判断是否缩放过量


        var lastScale = Math.max(iScrollOptions.zoomMin, Math.min(iScrollOptions.zoomMax, scale));

        if (lastScale !== scale) {
          // 当缩放过量时，将 offset 换算为最终的正常比例对应的值
          offset.x = offset.x / scale * lastScale;
          offset.y = offset.y / scale * lastScale;
        } // 由于双指旋转时也伴随着缩放，因此这里代码执行完后，将会执行 iscroll 的 _zoomEnd
        // 而该方法会基于 touchstart 时记录的位置重新计算 x、y，这将导致手指离开屏幕后，移动层又会向回移动一段距离
        // 所以这里也要将 startX、startY 这两个值进行补差，而这个差值必须是最终的正常比例对应的值


        iScroll.startX += offset.x;
        iScroll.startY += offset.y;

        if (angle !== this._curAngle && duration && (0, utils.isNumber)(duration) && supportTransition !== undefined) {
          // 计算旋转层参考点，设为零位前后的偏移量
          offset = {
            x: (rectByOrigin0.left - rect.left) / scale,
            y: (rectByOrigin0.top - rect.top) / scale
          }; // 将旋转参考点设回前值，同时调整偏移量，保证视图位置不变，准备开始动画

          setOrigin(this._$rotateLayer, this._rotateLayerOriginX, this._rotateLayerOriginY);
          var targetX = this._rotateLayerX + this._moveLayerPaddingLeft + offset.x,
              targetY = this._rotateLayerY + this._moveLayerPaddingTop + offset.y;
          setTransform(this._$rotateLayer, targetX, targetY, this._curAngle); // 开始旋转

          this._atRotation = true;
          setTransition(this._$rotateLayer, targetX, targetY, angle, duration, function () {
            _this4._atRotation = false;

            _this4._rotateFinishUpdataElem(angle);
          });
        } else {
          this._rotateFinishUpdataElem(angle);
        }
      } // 旋转结束更新相关元素

    }, {
      key: "_rotateFinishUpdataElem",
      value: function _rotateFinishUpdataElem(angle) {
        setOrigin(this._$rotateLayer, this._rotateLayerOriginX = 0, this._rotateLayerOriginY = 0);
        setTransform(this._$rotateLayer, this._rotateLayerX + this._moveLayerPaddingLeft, this._rotateLayerY + this._moveLayerPaddingTop, this._curAngle = angle % 360);
      }
    }, {
      key: "_initFile",
      value: function _initFile() {
        var _this5 = this;

        var options = this._options;

        if (this._fileList = (0, utils.$)(options.file)) {
          this._fileList.forEach(function ($file) {
            // 移动端如果设置 'accept'，会使相册打开缓慢，因此这里只为非移动端设置
            if (!is_mobile) {
              (0, utils.attr)($file, 'accept', 'image/jpeg, image/x-png, image/png, image/gif');
            }

            $file.addEventListener('change', _this5._fileOnChangeHandle);
          });
        }
      }
    }, {
      key: "_fileOnChangeHandle",
      value: function _fileOnChangeHandle(e) {
        var files = e.target.files;

        if (files.length) {
          this._lrzHandle(files[0]);
        }
      }
    }, {
      key: "_lrzHandle",
      value: function _lrzHandle(src) {
        var _this6 = this;

        var options = this._options,
            errorMsg = options.errorMsg;

        if (_typeof(src) === 'object' && src.type && !/image\/\w+/.test(src.type)) {
          options.loadError.call(this, errorMsg.imgError);
          return false;
        }

        this._imgLoaded = false;
        options.loadStart.call(this, src);

        try {
          (0, _lrz["default"])(src, options.lrzOption).then(function (rst) {
            // 处理成功会执行
            _this6._clearImg();

            _this6._createImg(rst.base64);
          })["catch"](function (err) {
            // 处理失败会执行
            options.loadError.call(_this6, errorMsg.imgHandleError, err);
          });
        } catch (err) {
          options.loadError.call(this, errorMsg.imgHandleError, err);
          throw err;
        }
      }
    }, {
      key: "_clearImg",
      value: function _clearImg() {
        if (!this._$img) return; // 删除旧的图片以释放内存，防止IOS设备的 webview 崩溃

        this._$img.onload = null;
        this._$img.onerror = null;
        (0, utils.removeElement)(this._$img);
        this._$img = null;
        this._imgLoaded = false;
      }
    }, {
      key: "_createImg",
      value: function _createImg(src) {
        var _this7 = this;

        var options = this._options,
            errorMsg = options.errorMsg;
        this._$img = new Image();
        (0, utils.css)(this._$img, {
          'display': 'block',
          'user-select': 'none',
          'pointer-events': 'none'
        });

        this._$img.onload = function (e) {
          var img = e.target;
          _this7._imgLoaded = true;
          options.loadComplete.call(_this7, img);

          _this7._$rotateLayer.appendChild(img);

          _this7._rotateLayerWidth = img.naturalWidth;
          _this7._rotateLayerHeight = img.naturalHeight;
          (0, utils.css)(_this7._$rotateLayer, {
            'width': _this7._rotateLayerWidth,
            'height': _this7._rotateLayerHeight
          });
          (0, utils.hideAction)([img, _this7._$moveLayer], _this7._resetScroll);
        };

        this._$img.onerror = function (e) {
          options.loadError.call(_this7, errorMsg.imgLoadError, e);
        };

        (0, utils.attr)(this._$img, 'src', src);
      }
    }, {
      key: "_clipImg",
      value: function _clipImg() {
        var options = this._options,
            errorMsg = options.errorMsg;

        if (!this._imgLoaded) {
          options.fail.call(this, errorMsg.noImg);
          return;
        }

        var local = utils.loaclToLoacl(this._$moveLayer, this._$clipLayer),
            scale = this._iScroll.scale,
            ctx = this._canvas.getContext('2d');

        var scaleX = 1,
            scaleY = 1;

        if (this._outputWidth || this._outputHeight) {
          this._canvas.width = this._outputWidth;
          this._canvas.height = this._outputHeight;
          scaleX = this._outputWidth / this._clipWidth * scale;
          scaleY = this._outputHeight / this._clipHeight * scale;
        } else {
          this._canvas.width = this._clipWidth / scale;
          this._canvas.height = this._clipHeight / scale;
        }

        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        ctx.fillStyle = options.outputType === 'image/png' ? 'transparent' : options.style.jpgFillColor;
        ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
        ctx.save();
        ctx.scale(scaleX, scaleY);
        ctx.translate(this._rotateLayerX + this._moveLayerPaddingLeft - local.x / scale, this._rotateLayerY + this._moveLayerPaddingTop - local.y / scale);
        ctx.rotate(this._curAngle * Math.PI / 180);
        ctx.drawImage(this._$img, 0, 0);
        ctx.restore();

        try {
          var dataURL = this._canvas.toDataURL(options.outputType, options.outputQuality);

          if (this._viewList) {
            this._viewList.forEach(function ($view) {
              (0, utils.css)($view, 'background-image', "url(".concat(dataURL, ")"));
            });
          }

          options.done.call(this, dataURL);
          return dataURL;
        } catch (err) {
          options.fail.call(this, errorMsg.clipError);
          throw err;
        }
      }
    }, {
      key: "_resize",
      value: function _resize(width, height) {
        (0, utils.hideAction)(this._$container, function () {
          this._containerWidth = this._$container.offsetWidth;
          this._containerHeight = this._$container.offsetHeight;
        }, this);
        var size = this._options.size,
            oldClipWidth = this._clipWidth,
            oldClipHeight = this._clipHeight;
        if ((0, utils.isNumber)(width)) size[0] = width;
        if ((0, utils.isNumber)(height)) size[1] = height;

        if (this._widthIsPercent || this._heightIsPercent) {
          var ratio = size[0] / size[1];

          if (this._widthIsPercent) {
            this._clipWidth = this._containerWidth / 100 * parseFloat(this._widthIsPercent);

            if (!this._heightIsPercent) {
              this._clipHeight = this._clipWidth / ratio;
            }
          }

          if (this._heightIsPercent) {
            this._clipHeight = this._containerHeight / 100 * parseFloat(this._heightIsPercent);

            if (!this._widthIsPercent) {
              this._clipWidth = this._clipHeight * ratio;
            }
          }
        } else {
          this._clipWidth = size[0];
          this._clipHeight = size[1];
        }

        var clipWidth = this._clipWidth,
            clipHeight = this._clipHeight;
        this._clipSizeRatio = clipWidth / clipHeight;

        if (this._outputWidth && !this._outputHeight) {
          this._outputHeight = this._outputWidth / this._clipSizeRatio;
        }

        if (this._outputHeight && !this._outputWidth) {
          this._outputWidth = this._outputHeight * this._clipSizeRatio;
        }

        (0, utils.css)(this._$clipLayer, {
          'width': clipWidth,
          'height': clipHeight,
          'margin-left': -clipWidth / 2,
          'margin-top': -clipHeight / 2
        });
        (0, utils.css)(this._$mask_left, {
          'margin-right': clipWidth / 2,
          'margin-top': -clipHeight / 2,
          'margin-bottom': -clipHeight / 2
        });
        (0, utils.css)(this._$mask_right, {
          'margin-left': clipWidth / 2,
          'margin-top': -clipHeight / 2,
          'margin-bottom': -clipHeight / 2
        });
        (0, utils.css)(this._$mask_top, {
          'margin-bottom': clipHeight / 2
        });
        (0, utils.css)(this._$mask_bottom, {
          'margin-top': clipHeight / 2
        });
        (0, utils.css)(this._$clip_frame, {
          'width': clipWidth,
          'height': clipHeight
        });
        (0, utils.css)(this._$clip_frame, prefix + 'transform', 'translate(-50%, -50%)');

        if (clipWidth !== oldClipWidth || clipHeight !== oldClipHeight) {
          this._calcScale();

          this._resizeMoveLayer();

          this._refreshScroll();

          var iScroll = this._iScroll,
              scale = iScroll.scale,
              offsetX = (clipWidth - oldClipWidth) * .5 * scale,
              offsetY = (clipHeight - oldClipHeight) * .5 * scale;
          iScroll.scrollBy(offsetX, offsetY);
        }
      }
      /**
       * 设置截取框的宽高
       * 如果设置了 adaptive 选项，则该方法仅用于修改截取框的宽高比例
       * @param  {Number} width  截取框的宽度
       * @param  {Number} height 截取框的高度
       * @return {PhotoClip}     返回 PhotoClip 的实例对象
       */

    }, {
      key: "size",
      value: function size(width, height) {
        this._resize(width, height);

        return this;
      }
      /**
       * 加载一张图片
       * @param  {String|Object} src 图片的 url，或者图片的 file 文件对象
       * @return {PhotoClip}         返回 PhotoClip 的实例对象
       */

    }, {
      key: "load",
      value: function load(src) {
        this._lrzHandle(src);

        return this;
      }
      /**
       * 清除当前图片
       * @return {PhotoClip}  返回 PhotoClip 的实例对象
       */

    }, {
      key: "clear",
      value: function clear() {
        this._clearImg();

        this._resetScroll();

        if (this._fileList) {
          this._fileList.forEach(function ($file) {
            $file.value = '';
          });
        }

        return this;
      }
      /**
       * 图片旋转到指定角度
       * @param  {Number} angle      可选。旋转的角度
       * @param  {Number} duration   可选。旋转动画的时长，如果为 0 或 false，则表示没有过渡动画
       * @return {PhotoClip|Number}  返回 PhotoClip 的实例对象。如果参数为空，则返回当前的旋转角度
       */

    }, {
      key: "rotate",
      value: function rotate(angle, duration) {
        if (angle === undefined) return this._curAngle;

        this._rotateTo(angle, duration);

        return this;
      }
      /**
       * 图片缩放到指定比例，如果超出缩放范围，则会被缩放到可缩放极限
       * @param  {Number} zoom       可选。缩放比例，取值在 0 - 1 之间
       * @param  {Number} duration   可选。缩放动画的时长，如果为 0 或 false，则表示没有过渡动画
       * @return {PhotoClip|Number}  返回 PhotoClip 的实例对象。如果参数为空，则返回当前的缩放比例
       */

    }, {
      key: "scale",
      value: function scale(zoom, duration) {
        if (zoom === undefined) return this._iScroll.scale;

        this._iScroll.zoom(zoom, undefined, undefined, duration);

        return this;
      }
      /**
       * 截图
       * @return {String}  返回截取后图片的 Base64 字符串
       */

    }, {
      key: "clip",
      value: function clip() {
        return this._clipImg();
      }
      /**
       * 销毁
       * @return {Undefined}  无返回值
       */

    }, {
      key: "destroy",
      value: function destroy() {
        var _this8 = this;

        window.removeEventListener('resize', this._resize);

        this._$container.removeChild(this._$clipLayer);

        this._$container.removeChild(this._$mask);

        (0, utils.css)(this._$container, this._containerOriginStyle);

        if (this._iScroll) {
          this._iScroll.destroy();
        }

        if (this._hammerManager) {
          this._hammerManager.off('rotatemove');

          this._hammerManager.off('rotateend');

          this._hammerManager.destroy();
        } else {
          this._$moveLayer.removeEventListener('dblclick', this._rotateCW90);
        }

        if (this._$img) {
          this._$img.onload = null;
          this._$img.onerror = null;
        }

        if (this._viewList) {
          this._viewList.forEach(function ($view, i) {
            (0, utils.css)($view, _this8._viewOriginStyleList[i]);
          });
        }

        if (this._fileList) {
          this._fileList.forEach(function ($file) {
            $file.removeEventListener('change', _this8._fileOnChangeHandle);
            $file.value = null;
          });
        }

        if (this._okList) {
          this._okList.forEach(function ($ok) {
            $ok.removeEventListener('click', _this8._clipImg);
          });
        }

        (0, utils.destroy)(this);
      }
    }]);

    return PhotoClip;
  }();

  _exports["default"] = PhotoClip;
  ; // 设置变换注册点

  function setOrigin($obj, originX, originY) {
    var prefix2 = (0, utils.support)('transform');
    originX = (originX || 0).toFixed(2);
    originY = (originY || 0).toFixed(2);
    (0, utils.css)($obj, prefix2 + 'transform-origin', originX + 'px ' + originY + 'px');
  } // 设置变换坐标与旋转角度


  function setTransform($obj, x, y, angle) {
    var prefix2 = (0, utils.support)('transform'); // translate(x, y) 中坐标的小数点位数过多会引发 bug
    // 因此这里需要保留两位小数

    x = x.toFixed(2);
    y = y.toFixed(2);
    angle = angle.toFixed(2);
    (0, utils.css)($obj, prefix2 + 'transform', 'translateZ(0) translate(' + x + 'px,' + y + 'px) rotate(' + angle + 'deg)');
  } // 设置变换动画


  function setTransition($obj, x, y, angle, dur, fn) {
    var prefix2 = (0, utils.support)('transform'); // 这里需要先读取之前设置好的transform样式，强制浏览器将该样式值渲染到元素
    // 否则浏览器可能出于性能考虑，将暂缓样式渲染，等到之后所有样式设置完成后再统一渲染
    // 这样就会导致之前设置的位移也被应用到动画中

    (0, utils.css)($obj, prefix2 + 'transform'); // 这里应用的缓动与 iScroll 的默认缓动相同

    (0, utils.css)($obj, prefix2 + 'transition', prefix2 + 'transform ' + dur + 'ms cubic-bezier(0.1, 0.57, 0.1, 1)');
    setTransform($obj, x, y, angle);
    setTimeout(function () {
      (0, utils.css)($obj, prefix2 + 'transition', '');
      fn();
    }, dur);
  }
});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  /*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */
  (function (window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');
    var TYPE_FUNCTION = 'function';
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */

    function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
    }
    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */


    function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
      }

      return false;
    }
    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */


    function each(obj, iterator, context) {
      var i;

      if (!obj) {
        return;
      }

      if (obj.forEach) {
        obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
        i = 0;

        while (i < obj.length) {
          iterator.call(context, obj[i], i, obj);
          i++;
        }
      } else {
        for (i in obj) {
          obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
      }
    }
    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */


    function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function () {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
        var log = window.console && (window.console.warn || window.console.log);

        if (log) {
          log.call(window.console, deprecationMessage, stack);
        }

        return method.apply(this, arguments);
      };
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */


    var assign;

    if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
        if (target === undefined || target === null) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);

        for (var index = 1; index < arguments.length; index++) {
          var source = arguments[index];

          if (source !== undefined && source !== null) {
            for (var nextKey in source) {
              if (source.hasOwnProperty(nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }

        return output;
      };
    } else {
      assign = Object.assign;
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */


    var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;

      while (i < keys.length) {
        if (!merge || merge && dest[keys[i]] === undefined) {
          dest[keys[i]] = src[keys[i]];
        }

        i++;
      }

      return dest;
    }, 'extend', 'Use `assign`.');
    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */

    var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');
    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */

    function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;
      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
        assign(childP, properties);
      }
    }
    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */


    function bindFn(fn, context) {
      return function boundFn() {
        return fn.apply(context, arguments);
      };
    }
    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */


    function boolOrFn(val, args) {
      if (_typeof(val) == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
      }

      return val;
    }
    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */


    function ifUndefined(val1, val2) {
      return val1 === undefined ? val2 : val1;
    }
    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */


    function addEventListeners(target, types, handler) {
      each(splitStr(types), function (type) {
        target.addEventListener(type, handler, false);
      });
    }
    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */


    function removeEventListeners(target, types, handler) {
      each(splitStr(types), function (type) {
        target.removeEventListener(type, handler, false);
      });
    }
    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */


    function hasParent(node, parent) {
      while (node) {
        if (node == parent) {
          return true;
        }

        node = node.parentNode;
      }

      return false;
    }
    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */


    function inStr(str, find) {
      return str.indexOf(find) > -1;
    }
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */


    function splitStr(str) {
      return str.trim().split(/\s+/g);
    }
    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */


    function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
        return src.indexOf(find);
      } else {
        var i = 0;

        while (i < src.length) {
          if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
            return i;
          }

          i++;
        }

        return -1;
      }
    }
    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */


    function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
    }
    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */


    function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
        var val = key ? src[i][key] : src[i];

        if (inArray(values, val) < 0) {
          results.push(src[i]);
        }

        values[i] = val;
        i++;
      }

      if (sort) {
        if (!key) {
          results = results.sort();
        } else {
          results = results.sort(function sortUniqueArray(a, b) {
            return a[key] > b[key];
          });
        }
      }

      return results;
    }
    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */


    function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);
      var i = 0;

      while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = prefix ? prefix + camelProp : property;

        if (prop in obj) {
          return prop;
        }

        i++;
      }

      return undefined;
    }
    /**
     * get a unique id
     * @returns {number} uniqueId
     */


    var _uniqueId = 1;

    function uniqueId() {
      return _uniqueId++;
    }
    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */


    function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return doc.defaultView || doc.parentWindow || window;
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = 'ontouchstart' in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];
    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */

    function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.

      this.domHandler = function (ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
          self.handler(ev);
        }
      };

      this.init();
    }

    Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function handler() {},

      /**
       * bind the events
       */
      init: function init() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function destroy() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
    };
    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */

    function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
        Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
      } else {
        Type = TouchMouseInput;
      }

      return new Type(manager, inputHandler);
    }
    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */


    function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
      var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
        manager.session = {};
      } // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'


      input.eventType = eventType; // compute scale, rotation etc

      computeInputData(manager, input); // emit secret event

      manager.emit('hammer.input', input);
      manager.recognize(input);
      manager.session.prevInput = input;
    }
    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */


    function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length; // store the first input to calculate the distance and direction

      if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
      } // to compute scale and rotation we need to store the multiple touches


      if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
        session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;
      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);
      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);
      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
      input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
      computeIntervalInputData(session, input); // find the correct target

      var target = manager.element;

      if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
      }

      input.target = target;
    }

    function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
          x: prevInput.deltaX || 0,
          y: prevInput.deltaY || 0
        };
        offset = session.offsetDelta = {
          x: center.x,
          y: center.y
        };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */


    function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity,
          velocityX,
          velocityY,
          direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;
        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);
        session.lastInterval = input;
      } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
    }
    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */


    function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;

      while (i < input.pointers.length) {
        pointers[i] = {
          clientX: round(input.pointers[i].clientX),
          clientY: round(input.pointers[i].clientY)
        };
        i++;
      }

      return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
      };
    }
    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */


    function getCenter(pointers) {
      var pointersLength = pointers.length; // no need to loop when only one touch

      if (pointersLength === 1) {
        return {
          x: round(pointers[0].clientX),
          y: round(pointers[0].clientY)
        };
      }

      var x = 0,
          y = 0,
          i = 0;

      while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
      }

      return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
      };
    }
    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */


    function getVelocity(deltaTime, x, y) {
      return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
      };
    }
    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */


    function getDirection(x, y) {
      if (x === y) {
        return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }

      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */


    function getDistance(p1, p2, props) {
      if (!props) {
        props = PROPS_XY;
      }

      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.sqrt(x * x + y * y);
    }
    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */


    function getAngle(p1, p2, props) {
      if (!props) {
        props = PROPS_XY;
      }

      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */


    function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */


    function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */

    function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;
      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

        if (eventType & INPUT_START && ev.button === 0) {
          this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
          eventType = INPUT_END;
        } // mouse must be down


        if (!this.pressed) {
          return;
        }

        if (eventType & INPUT_END) {
          this.pressed = false;
        }

        this.callback(this.manager, eventType, {
          pointers: [ev],
          changedPointers: [ev],
          pointerType: INPUT_TYPE_MOUSE,
          srcEvent: ev
        });
      }
    });
    var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
    }; // in IE10 the pointer types is defined as an enum

    var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

    };
    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

    if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }
    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */


    function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;
      Input.apply(this, arguments);
      this.store = this.manager.session.pointerEvents = [];
    }

    inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;
        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
        var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

        var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
          if (storeIndex < 0) {
            store.push(ev);
            storeIndex = store.length - 1;
          }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          removePointer = true;
        } // it not found, so the pointer hasn't been down (so it's probably a hover)


        if (storeIndex < 0) {
          return;
        } // update the event in the store


        store[storeIndex] = ev;
        this.callback(this.manager, eventType, {
          pointers: store,
          changedPointers: [ev],
          pointerType: pointerType,
          srcEvent: ev
        });

        if (removePointer) {
          // remove from the store
          store.splice(storeIndex, 1);
        }
      }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
     * Touch events input
     * @constructor
     * @extends Input
     */

    function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;
      Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

        if (type === INPUT_START) {
          this.started = true;
        }

        if (!this.started) {
          return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
          this.started = false;
        }

        this.callback(this.manager, type, {
          pointers: touches[0],
          changedPointers: touches[1],
          pointerType: INPUT_TYPE_TOUCH,
          srcEvent: ev
        });
      }
    });
    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */

    function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */

    function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};
      Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);

        if (!touches) {
          return;
        }

        this.callback(this.manager, type, {
          pointers: touches[0],
          changedPointers: touches[1],
          pointerType: INPUT_TYPE_TOUCH,
          srcEvent: ev
        });
      }
    });
    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */

    function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target; // get target touches from touches

      targetTouches = allTouches.filter(function (touch) {
        return hasParent(touch.target, target);
      }); // collect touches

      if (type === INPUT_START) {
        i = 0;

        while (i < targetTouches.length) {
          targetIds[targetTouches[i].identifier] = true;
          i++;
        }
      } // filter changed touches to only contain touches that exist in the collected target ids


      i = 0;

      while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
          changedTargetTouches.push(changedTouches[i]);
        } // cleanup removed touches


        if (type & (INPUT_END | INPUT_CANCEL)) {
          delete targetIds[changedTouches[i].identifier];
        }

        i++;
      }

      if (!changedTargetTouches.length) {
        return;
      }

      return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
      uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */


    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
      Input.apply(this, arguments);
      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);
      this.primaryTouch = null;
      this.lastTouches = [];
    }

    inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
            isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
          return;
        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


        if (isTouch) {
          recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
          return;
        }

        this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
      }
    });

    function recordTouches(eventType, eventData) {
      if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
      }
    }

    function setLastTouch(eventData) {
      var touch = eventData.changedPointers[0];

      if (touch.identifier === this.primaryTouch) {
        var lastTouch = {
          x: touch.clientX,
          y: touch.clientY
        };
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;

        var removeLastTouch = function removeLastTouch() {
          var i = lts.indexOf(lastTouch);

          if (i > -1) {
            lts.splice(i, 1);
          }
        };

        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
      }
    }

    function isSyntheticEvent(eventData) {
      var x = eventData.srcEvent.clientX,
          y = eventData.srcEvent.clientY;

      for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x),
            dy = Math.abs(y - t.y);

        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
          return true;
        }
      }

      return false;
    }

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();
    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */

    function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
    }

    TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function set(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
          value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
          this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }

        this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function update() {
        this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function compute() {
        var actions = [];
        each(this.manager.recognizers, function (recognizer) {
          if (boolOrFn(recognizer.options.enable, [recognizer])) {
            actions = actions.concat(recognizer.getTouchAction());
          }
        });
        return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function preventDefaults(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection; // if the touch action did prevented once this session

        if (this.manager.session.prevented) {
          srcEvent.preventDefault();
          return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
          //do not prevent defaults if this is a tap gesture
          var isTapPointer = input.pointers.length === 1;
          var isTapMovement = input.distance < 2;
          var isTapTouchTime = input.deltaTime < 250;

          if (isTapPointer && isTapMovement && isTapTouchTime) {
            return;
          }
        }

        if (hasPanX && hasPanY) {
          // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
          return;
        }

        if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
          return this.preventSrc(srcEvent);
        }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function preventSrc(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
      }
    };
    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */

    function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning

      if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
      } // pan-x OR pan-y


      if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      } // manipulation


      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
    }

    function getTouchActionProps() {
      if (!NATIVE_TOUCH_ACTION) {
        return false;
      }

      var touchMap = {};
      var cssSupports = window.CSS && window.CSS.supports;
      ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
      });
      return touchMap;
    }
    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */


    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */

    function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});
      this.id = uniqueId();
      this.manager = null; // default is enable true

      this.options.enable = ifUndefined(this.options.enable, true);
      this.state = STATE_POSSIBLE;
      this.simultaneous = {};
      this.requireFail = [];
    }

    Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function set(options) {
        assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

        this.manager && this.manager.touchAction.update();
        return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function recognizeWith(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
          return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

        if (!simultaneous[otherRecognizer.id]) {
          simultaneous[otherRecognizer.id] = otherRecognizer;
          otherRecognizer.recognizeWith(this);
        }

        return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
          return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function requireFailure(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
          return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

        if (inArray(requireFail, otherRecognizer) === -1) {
          requireFail.push(otherRecognizer);
          otherRecognizer.requireFailure(this);
        }

        return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function dropRequireFailure(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
          return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);

        if (index > -1) {
          this.requireFail.splice(index, 1);
        }

        return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function hasRequireFailures() {
        return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function canRecognizeWith(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function emit(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
          self.manager.emit(event, input);
        } // 'panstart' and 'panmove'


        if (state < STATE_ENDED) {
          emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) {
          // additional event(panleft, panright, pinchin, pinchout...)
          emit(input.additionalEvent);
        } // panend and pancancel


        if (state >= STATE_ENDED) {
          emit(self.options.event + stateStr(state));
        }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function tryEmit(input) {
        if (this.canEmit()) {
          return this.emit(input);
        } // it's failing anyway


        this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function canEmit() {
        var i = 0;

        while (i < this.requireFail.length) {
          if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
            return false;
          }

          i++;
        }

        return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function recognize(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
          this.reset();
          this.state = STATE_FAILED;
          return;
        } // reset when we've reached the end


        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
          this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
        // so trigger an event

        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
          this.tryEmit(inputDataClone);
        }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function process(inputData) {},
      // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function getTouchAction() {},

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function reset() {}
    };
    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */

    function stateStr(state) {
      if (state & STATE_CANCELLED) {
        return 'cancel';
      } else if (state & STATE_ENDED) {
        return 'end';
      } else if (state & STATE_CHANGED) {
        return 'move';
      } else if (state & STATE_BEGAN) {
        return 'start';
      }

      return '';
    }
    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */


    function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
        return 'down';
      } else if (direction == DIRECTION_UP) {
        return 'up';
      } else if (direction == DIRECTION_LEFT) {
        return 'left';
      } else if (direction == DIRECTION_RIGHT) {
        return 'right';
      }

      return '';
    }
    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */


    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;

      if (manager) {
        return manager.get(otherRecognizer);
      }

      return otherRecognizer;
    }
    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */


    function AttrRecognizer() {
      Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function attrTest(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function process(input) {
        var state = this.state;
        var eventType = input.eventType;
        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
          return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
          if (eventType & INPUT_END) {
            return state | STATE_ENDED;
          } else if (!(state & STATE_BEGAN)) {
            return STATE_BEGAN;
          }

          return state | STATE_CHANGED;
        }

        return STATE_FAILED;
      }
    });
    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */

    function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);
      this.pX = null;
      this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
      },
      getTouchAction: function getTouchAction() {
        var direction = this.options.direction;
        var actions = [];

        if (direction & DIRECTION_HORIZONTAL) {
          actions.push(TOUCH_ACTION_PAN_Y);
        }

        if (direction & DIRECTION_VERTICAL) {
          actions.push(TOUCH_ACTION_PAN_X);
        }

        return actions;
      },
      directionTest: function directionTest(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY; // lock to axis?

        if (!(direction & options.direction)) {
          if (options.direction & DIRECTION_HORIZONTAL) {
            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            hasMoved = x != this.pX;
            distance = Math.abs(input.deltaX);
          } else {
            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
            hasMoved = y != this.pY;
            distance = Math.abs(input.deltaY);
          }
        }

        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
      },
      attrTest: function attrTest(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
      },
      emit: function emit(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;
        var direction = directionStr(input.direction);

        if (direction) {
          input.additionalEvent = this.options.event + direction;
        }

        this._super.emit.call(this, input);
      }
    });
    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */

    function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function getTouchAction() {
        return [TOUCH_ACTION_NONE];
      },
      attrTest: function attrTest(input) {
        return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },
      emit: function emit(input) {
        if (input.scale !== 1) {
          var inOut = input.scale < 1 ? 'in' : 'out';
          input.additionalEvent = this.options.event + inOut;
        }

        this._super.emit.call(this, input);
      }
    });
    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */

    function PressRecognizer() {
      Recognizer.apply(this, arguments);
      this._timer = null;
      this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: 'press',
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low

      },
      getTouchAction: function getTouchAction() {
        return [TOUCH_ACTION_AUTO];
      },
      process: function process(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;
        this._input = input; // we only allow little movement
        // and we've reached an end event, so a tap is possible

        if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
          this.reset();
        } else if (input.eventType & INPUT_START) {
          this.reset();
          this._timer = setTimeoutContext(function () {
            this.state = STATE_RECOGNIZED;
            this.tryEmit();
          }, options.time, this);
        } else if (input.eventType & INPUT_END) {
          return STATE_RECOGNIZED;
        }

        return STATE_FAILED;
      },
      reset: function reset() {
        clearTimeout(this._timer);
      },
      emit: function emit(input) {
        if (this.state !== STATE_RECOGNIZED) {
          return;
        }

        if (input && input.eventType & INPUT_END) {
          this.manager.emit(this.options.event + 'up', input);
        } else {
          this._input.timeStamp = now();
          this.manager.emit(this.options.event, this._input);
        }
      }
    });
    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */

    function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function getTouchAction() {
        return [TOUCH_ACTION_NONE];
      },
      attrTest: function attrTest(input) {
        return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
    });
    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */

    function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
      },
      getTouchAction: function getTouchAction() {
        return PanRecognizer.prototype.getTouchAction.call(this);
      },
      attrTest: function attrTest(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
          velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
          velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
          velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },
      emit: function emit(input) {
        var direction = directionStr(input.offsetDirection);

        if (direction) {
          this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
      }
    });
    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */

    function TapRecognizer() {
      Recognizer.apply(this, arguments); // previous time and center,
      // used for tap counting

      this.pTime = false;
      this.pCenter = false;
      this._timer = null;
      this._input = null;
      this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position

      },
      getTouchAction: function getTouchAction() {
        return [TOUCH_ACTION_MANIPULATION];
      },
      process: function process(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;
        this.reset();

        if (input.eventType & INPUT_START && this.count === 0) {
          return this.failTimeout();
        } // we only allow little movement
        // and we've reached an end event, so a tap is possible


        if (validMovement && validTouchTime && validPointers) {
          if (input.eventType != INPUT_END) {
            return this.failTimeout();
          }

          var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
          var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
          this.pTime = input.timeStamp;
          this.pCenter = input.center;

          if (!validMultiTap || !validInterval) {
            this.count = 1;
          } else {
            this.count += 1;
          }

          this._input = input; // if tap count matches we have recognized it,
          // else it has began recognizing...

          var tapCount = this.count % options.taps;

          if (tapCount === 0) {
            // no failing requirements, immediately trigger the tap event
            // or wait as long as the multitap interval to trigger
            if (!this.hasRequireFailures()) {
              return STATE_RECOGNIZED;
            } else {
              this._timer = setTimeoutContext(function () {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.interval, this);
              return STATE_BEGAN;
            }
          }
        }

        return STATE_FAILED;
      },
      failTimeout: function failTimeout() {
        this._timer = setTimeoutContext(function () {
          this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
      },
      reset: function reset() {
        clearTimeout(this._timer);
      },
      emit: function emit() {
        if (this.state == STATE_RECOGNIZED) {
          this._input.tapCount = this.count;
          this.manager.emit(this.options.event, this._input);
        }
      }
    });
    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */

    function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
    }
    /**
     * @const {string}
     */


    Hammer.VERSION = '2.0.7';
    /**
     * default settings
     * @namespace
     */

    Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
      [RotateRecognizer, {
        enable: false
      }], [PinchRecognizer, {
        enable: false
      }, ['rotate']], [SwipeRecognizer, {
        direction: DIRECTION_HORIZONTAL
      }], [PanRecognizer, {
        direction: DIRECTION_HORIZONTAL
      }, ['swipe']], [TapRecognizer], [TapRecognizer, {
        event: 'doubletap',
        taps: 2
      }, ['tap']], [PressRecognizer]],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
      }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */

    function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});
      this.options.inputTarget = this.options.inputTarget || element;
      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};
      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);
      toggleCssProps(this, true);
      each(this.options.recognizers, function (item) {
        var recognizer = this.add(new item[0](item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
      }, this);
    }

    Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function set(options) {
        assign(this.options, options); // Options that need a little more setup

        if (options.touchAction) {
          this.touchAction.update();
        }

        if (options.inputTarget) {
          // Clean up existing event listeners and reinitialize
          this.input.destroy();
          this.input.target = options.inputTarget;
          this.input.init();
        }

        return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function stop(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function recognize(inputData) {
        var session = this.session;

        if (session.stopped) {
          return;
        } // run the touch-action polyfill


        this.touchAction.preventDefaults(inputData);
        var recognizer;
        var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`

        var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
        // or when we're in a new session

        if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
          curRecognizer = session.curRecognizer = null;
        }

        var i = 0;

        while (i < recognizers.length) {
          recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
          // 1.   allow if the session is NOT forced stopped (see the .stop() method)
          // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
          //      that is being recognized.
          // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
          //      this can be setup with the `recognizeWith()` method on the recognizer.

          if (session.stopped !== FORCED_STOP && ( // 1
          !curRecognizer || recognizer == curRecognizer || // 2
          recognizer.canRecognizeWith(curRecognizer))) {
            // 3
            recognizer.recognize(inputData);
          } else {
            recognizer.reset();
          } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
          // current active recognizer. but only if we don't already have an active recognizer


          if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
            curRecognizer = session.curRecognizer = recognizer;
          }

          i++;
        }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function get(recognizer) {
        if (recognizer instanceof Recognizer) {
          return recognizer;
        }

        var recognizers = this.recognizers;

        for (var i = 0; i < recognizers.length; i++) {
          if (recognizers[i].options.event == recognizer) {
            return recognizers[i];
          }
        }

        return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function add(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
          return this;
        } // remove existing


        var existing = this.get(recognizer.options.event);

        if (existing) {
          this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;
        this.touchAction.update();
        return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function remove(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
          return this;
        }

        recognizer = this.get(recognizer); // let's make sure this recognizer exists

        if (recognizer) {
          var recognizers = this.recognizers;
          var index = inArray(recognizers, recognizer);

          if (index !== -1) {
            recognizers.splice(index, 1);
            this.touchAction.update();
          }
        }

        return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function on(events, handler) {
        if (events === undefined) {
          return;
        }

        if (handler === undefined) {
          return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function (event) {
          handlers[event] = handlers[event] || [];
          handlers[event].push(handler);
        });
        return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function off(events, handler) {
        if (events === undefined) {
          return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function (event) {
          if (!handler) {
            delete handlers[event];
          } else {
            handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
          }
        });
        return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function emit(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
          triggerDomEvent(event, data);
        } // no handlers, so skip it all


        var handlers = this.handlers[event] && this.handlers[event].slice();

        if (!handlers || !handlers.length) {
          return;
        }

        data.type = event;

        data.preventDefault = function () {
          data.srcEvent.preventDefault();
        };

        var i = 0;

        while (i < handlers.length) {
          handlers[i](data);
          i++;
        }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function destroy() {
        this.element && toggleCssProps(this, false);
        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
      }
    };
    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */

    function toggleCssProps(manager, add) {
      var element = manager.element;

      if (!element.style) {
        return;
      }

      var prop;
      each(manager.options.cssProps, function (value, name) {
        prop = prefixed(element.style, name);

        if (add) {
          manager.oldCssProps[prop] = element.style[prop];
          element.style[prop] = value;
        } else {
          element.style[prop] = manager.oldCssProps[prop] || '';
        }
      });

      if (!add) {
        manager.oldCssProps = {};
      }
    }
    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */


    function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,
      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,
      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,
      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,
      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,
      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,
      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
    }); // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.

    var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

    freeGlobal.Hammer = Hammer;

    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return Hammer;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(window, document, 'Hammer');
});

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  /*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
  (function (window, document, Math) {
    var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
      window.setTimeout(callback, 1000 / 60);
    };

    var utils = function () {
      var me = {};
      var _elementStyle = document.createElement('div').style;

      var _vendor = function () {
        var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
            transform,
            i = 0,
            l = vendors.length;

        for (; i < l; i++) {
          transform = vendors[i] + 'ransform';
          if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
        }

        return false;
      }();

      function _prefixStyle(style) {
        if (_vendor === false) return false;
        if (_vendor === '') return style;
        return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
      }

      me.getTime = Date.now || function getTime() {
        return new Date().getTime();
      };

      me.extend = function (target, obj) {
        for (var i in obj) {
          target[i] = obj[i];
        }
      };

      me.addEvent = function (el, type, fn, capture) {
        el.addEventListener(type, fn, !!capture);
      };

      me.removeEvent = function (el, type, fn, capture) {
        el.removeEventListener(type, fn, !!capture);
      };

      me.prefixPointerEvent = function (pointerEvent) {
        return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8) : pointerEvent;
      };

      me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
        var distance = current - start,
            speed = Math.abs(distance) / time,
            destination,
            duration;
        deceleration = deceleration === undefined ? 0.0006 : deceleration;
        destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
        duration = speed / deceleration;

        if (destination < lowerMargin) {
          destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
          distance = Math.abs(destination - current);
          duration = distance / speed;
        } else if (destination > 0) {
          destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
          distance = Math.abs(current) + destination;
          duration = distance / speed;
        }

        return {
          destination: Math.round(destination),
          duration: duration
        };
      };

      var _transform = _prefixStyle('transform');

      me.extend(me, {
        hasTransform: _transform !== false,
        hasPerspective: _prefixStyle('perspective') in _elementStyle,
        hasTouch: 'ontouchstart' in window,
        hasPointer: !!(window.PointerEvent || window.MSPointerEvent),
        // IE10 is prefixed
        hasTransition: _prefixStyle('transition') in _elementStyle
      });
      /*
      This should find all Android browsers lower than build 535.19 (both stock browser and webview)
      - galaxy S2 is ok
         - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
         - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
        - galaxy S3 is badAndroid (stock brower, webview)
          `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
        - galaxy S4 is badAndroid (stock brower, webview)
          `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
        - galaxy S5 is OK
          `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
        - galaxy S6 is OK
          `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
       */

      me.isBadAndroid = function () {
        var appVersion = window.navigator.appVersion; // Android browser is not a chrome browser.

        if (/Android/.test(appVersion) && !/Chrome\/\d/.test(appVersion)) {
          var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);

          if (safariVersion && _typeof(safariVersion) === "object" && safariVersion.length >= 2) {
            return parseFloat(safariVersion[1]) < 535.19;
          } else {
            return true;
          }
        } else {
          return false;
        }
      }();

      me.extend(me.style = {}, {
        transform: _transform,
        transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
        transitionDuration: _prefixStyle('transitionDuration'),
        transitionDelay: _prefixStyle('transitionDelay'),
        transformOrigin: _prefixStyle('transformOrigin')
      });

      me.hasClass = function (e, c) {
        var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
        return re.test(e.className);
      };

      me.addClass = function (e, c) {
        if (me.hasClass(e, c)) {
          return;
        }

        var newclass = e.className.split(' ');
        newclass.push(c);
        e.className = newclass.join(' ');
      };

      me.removeClass = function (e, c) {
        if (!me.hasClass(e, c)) {
          return;
        }

        var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
        e.className = e.className.replace(re, ' ');
      };

      me.offset = function (el) {
        var left = -el.offsetLeft,
            top = -el.offsetTop; // jshint -W084

        while (el = el.offsetParent) {
          left -= el.offsetLeft;
          top -= el.offsetTop;
        } // jshint +W084


        return {
          left: left,
          top: top
        };
      };

      me.preventDefaultException = function (el, exceptions) {
        for (var i in exceptions) {
          if (exceptions[i].test(el[i])) {
            return true;
          }
        }

        return false;
      };

      me.extend(me.eventType = {}, {
        touchstart: 1,
        touchmove: 1,
        touchend: 1,
        mousedown: 2,
        mousemove: 2,
        mouseup: 2,
        pointerdown: 3,
        pointermove: 3,
        pointerup: 3,
        MSPointerDown: 3,
        MSPointerMove: 3,
        MSPointerUp: 3
      });
      me.extend(me.ease = {}, {
        quadratic: {
          style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
          fn: function fn(k) {
            return k * (2 - k);
          }
        },
        circular: {
          style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',
          // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
          fn: function fn(k) {
            return Math.sqrt(1 - --k * k);
          }
        },
        back: {
          style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
          fn: function fn(k) {
            var b = 4;
            return (k = k - 1) * k * ((b + 1) * k + b) + 1;
          }
        },
        bounce: {
          style: '',
          fn: function fn(k) {
            if ((k /= 1) < 1 / 2.75) {
              return 7.5625 * k * k;
            } else if (k < 2 / 2.75) {
              return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            } else if (k < 2.5 / 2.75) {
              return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            } else {
              return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
          }
        },
        elastic: {
          style: '',
          fn: function fn(k) {
            var f = 0.22,
                e = 0.4;

            if (k === 0) {
              return 0;
            }

            if (k == 1) {
              return 1;
            }

            return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
          }
        }
      });

      me.tap = function (e, eventName) {
        var ev = document.createEvent('Event');
        ev.initEvent(eventName, true, true);
        ev.pageX = e.pageX;
        ev.pageY = e.pageY;
        e.target.dispatchEvent(ev);
      };

      me.click = function (e) {
        var target = e.target,
            ev;

        if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
          ev = document.createEvent('MouseEvents');
          ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
          ev._constructed = true;
          target.dispatchEvent(ev);
        }
      };

      return me;
    }();

    function IScroll(el, options) {
      this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
      this.scroller = this.wrapper.children[0];
      this.scrollerStyle = this.scroller.style; // cache style for better performance

      this.options = {
        resizeScrollbars: true,
        mouseWheelSpeed: 20,
        snapThreshold: 0.334,
        // INSERT POINT: OPTIONS
        disablePointer: !utils.hasPointer,
        disableTouch: utils.hasPointer || !utils.hasTouch,
        disableMouse: utils.hasPointer || utils.hasTouch,
        startX: 0,
        startY: 0,
        scrollY: true,
        directionLockThreshold: 5,
        momentum: true,
        bounce: true,
        bounceTime: 600,
        bounceEasing: '',
        preventDefault: true,
        preventDefaultException: {
          tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/
        },
        HWCompositing: true,
        useTransition: true,
        useTransform: true,
        bindToWrapper: typeof window.onmousedown === "undefined"
      };

      for (var i in options) {
        this.options[i] = options[i];
      } // Normalize options


      this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';
      this.options.useTransition = utils.hasTransition && this.options.useTransition;
      this.options.useTransform = utils.hasTransform && this.options.useTransform;
      this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
      this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault; // If you want eventPassthrough I have to lock one of the axes

      this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
      this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX; // With eventPassthrough we also need lockDirection mechanism

      this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
      this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;
      this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;
      this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

      if (this.options.tap === true) {
        this.options.tap = 'tap';
      }

      if (this.options.shrinkScrollbars == 'scale') {
        this.options.useTransition = false;
      }

      this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1; // INSERT POINT: NORMALIZATION
      // Some defaults

      this.x = 0;
      this.y = 0;
      this.directionX = 0;
      this.directionY = 0;
      this._events = {}; // INSERT POINT: DEFAULTS

      this._init();

      this.refresh();
      this.scrollTo(this.options.startX, this.options.startY);
      this.enable();
    }

    IScroll.prototype = {
      version: '5.2.0',
      _init: function _init() {
        this._initEvents();

        if (this.options.scrollbars || this.options.indicators) {
          this._initIndicators();
        }

        if (this.options.mouseWheel) {
          this._initWheel();
        }

        if (this.options.snap) {
          this._initSnap();
        }

        if (this.options.keyBindings) {
          this._initKeys();
        } // INSERT POINT: _init

      },
      destroy: function destroy() {
        this._initEvents(true);

        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = null;

        this._execEvent('destroy');
      },
      _transitionEnd: function _transitionEnd(e) {
        if (e.target != this.scroller || !this.isInTransition) {
          return;
        }

        this._transitionTime();

        if (!this.resetPosition(this.options.bounceTime)) {
          this.isInTransition = false;

          this._execEvent('scrollEnd');
        }
      },
      _start: function _start(e) {
        // React to left mouse button only
        if (utils.eventType[e.type] != 1) {
          // for button property
          // http://unixpapa.com/js/mouse.html
          var button;

          if (!e.which) {
            /* IE case */
            button = e.button < 2 ? 0 : e.button == 4 ? 1 : 2;
          } else {
            /* All others */
            button = e.button;
          }

          if (button !== 0) {
            return;
          }
        }

        if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
          return;
        }

        if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
          e.preventDefault();
        }

        var point = e.touches ? e.touches[0] : e,
            pos;
        this.initiated = utils.eventType[e.type];
        this.moved = false;
        this.distX = 0;
        this.distY = 0;
        this.directionX = 0;
        this.directionY = 0;
        this.directionLocked = 0;
        this.startTime = utils.getTime();

        if (this.options.useTransition && this.isInTransition) {
          this._transitionTime();

          this.isInTransition = false;
          pos = this.getComputedPosition();

          this._translate(Math.round(pos.x), Math.round(pos.y));

          this._execEvent('scrollEnd');
        } else if (!this.options.useTransition && this.isAnimating) {
          this.isAnimating = false;

          this._execEvent('scrollEnd');
        }

        this.startX = this.x;
        this.startY = this.y;
        this.absStartX = this.x;
        this.absStartY = this.y;
        this.pointX = point.pageX;
        this.pointY = point.pageY;

        this._execEvent('beforeScrollStart');
      },
      _move: function _move(e) {
        if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
          return;
        }

        if (this.options.preventDefault) {
          // increases performance on Android? TODO: check!
          e.preventDefault();
        }

        var point = e.touches ? e.touches[0] : e,
            deltaX = point.pageX - this.pointX,
            deltaY = point.pageY - this.pointY,
            timestamp = utils.getTime(),
            newX,
            newY,
            absDistX,
            absDistY;
        this.pointX = point.pageX;
        this.pointY = point.pageY;
        this.distX += deltaX;
        this.distY += deltaY;
        absDistX = Math.abs(this.distX);
        absDistY = Math.abs(this.distY); // We need to move at least 10 pixels for the scrolling to initiate

        if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
          return;
        } // If you are scrolling in one direction lock the other


        if (!this.directionLocked && !this.options.freeScroll) {
          if (absDistX > absDistY + this.options.directionLockThreshold) {
            this.directionLocked = 'h'; // lock horizontally
          } else if (absDistY >= absDistX + this.options.directionLockThreshold) {
            this.directionLocked = 'v'; // lock vertically
          } else {
            this.directionLocked = 'n'; // no lock
          }
        }

        if (this.directionLocked == 'h') {
          if (this.options.eventPassthrough == 'vertical') {
            e.preventDefault();
          } else if (this.options.eventPassthrough == 'horizontal') {
            this.initiated = false;
            return;
          }

          deltaY = 0;
        } else if (this.directionLocked == 'v') {
          if (this.options.eventPassthrough == 'horizontal') {
            e.preventDefault();
          } else if (this.options.eventPassthrough == 'vertical') {
            this.initiated = false;
            return;
          }

          deltaX = 0;
        }

        deltaX = this.hasHorizontalScroll ? deltaX : 0;
        deltaY = this.hasVerticalScroll ? deltaY : 0;
        newX = this.x + deltaX;
        newY = this.y + deltaY; // Slow down if outside of the boundaries

        if (newX > 0 || newX < this.maxScrollX) {
          newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
        }

        if (newY > 0 || newY < this.maxScrollY) {
          newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
        }

        this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
        this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

        if (!this.moved) {
          this._execEvent('scrollStart');
        }

        this.moved = true;

        this._translate(newX, newY);
        /* REPLACE START: _move */


        if (timestamp - this.startTime > 300) {
          this.startTime = timestamp;
          this.startX = this.x;
          this.startY = this.y;
        }
        /* REPLACE END: _move */

      },
      _end: function _end(e) {
        if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
          return;
        }

        if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
          e.preventDefault();
        }

        var point = e.changedTouches ? e.changedTouches[0] : e,
            momentumX,
            momentumY,
            duration = utils.getTime() - this.startTime,
            newX = Math.round(this.x),
            newY = Math.round(this.y),
            distanceX = Math.abs(newX - this.startX),
            distanceY = Math.abs(newY - this.startY),
            time = 0,
            easing = '';
        this.isInTransition = 0;
        this.initiated = 0;
        this.endTime = utils.getTime(); // reset if we are outside of the boundaries

        if (this.resetPosition(this.options.bounceTime)) {
          return;
        }

        this.scrollTo(newX, newY); // ensures that the last position is rounded
        // we scrolled less than 10 pixels

        if (!this.moved) {
          if (this.options.tap) {
            utils.tap(e, this.options.tap);
          }

          if (this.options.click) {
            utils.click(e);
          }

          this._execEvent('scrollCancel');

          return;
        }

        if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
          this._execEvent('flick');

          return;
        } // start momentum animation if needed


        if (this.options.momentum && duration < 300) {
          momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : {
            destination: newX,
            duration: 0
          };
          momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : {
            destination: newY,
            duration: 0
          };
          newX = momentumX.destination;
          newY = momentumY.destination;
          time = Math.max(momentumX.duration, momentumY.duration);
          this.isInTransition = 1;
        }

        if (this.options.snap) {
          var snap = this._nearestSnap(newX, newY);

          this.currentPage = snap;
          time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
          newX = snap.x;
          newY = snap.y;
          this.directionX = 0;
          this.directionY = 0;
          easing = this.options.bounceEasing;
        } // INSERT POINT: _end


        if (newX != this.x || newY != this.y) {
          // change easing function when scroller goes out of the boundaries
          if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
            easing = utils.ease.quadratic;
          }

          this.scrollTo(newX, newY, time, easing);
          return;
        }

        this._execEvent('scrollEnd');
      },
      _resize: function _resize() {
        var that = this;
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(function () {
          that.refresh();
        }, this.options.resizePolling);
      },
      resetPosition: function resetPosition(time) {
        var x = this.x,
            y = this.y;
        time = time || 0;

        if (!this.hasHorizontalScroll || this.x > 0) {
          x = 0;
        } else if (this.x < this.maxScrollX) {
          x = this.maxScrollX;
        }

        if (!this.hasVerticalScroll || this.y > 0) {
          y = 0;
        } else if (this.y < this.maxScrollY) {
          y = this.maxScrollY;
        }

        if (x == this.x && y == this.y) {
          return false;
        }

        this.scrollTo(x, y, time, this.options.bounceEasing);
        return true;
      },
      disable: function disable() {
        this.enabled = false;
      },
      enable: function enable() {
        this.enabled = true;
      },
      refresh: function refresh() {
        var rf = this.wrapper.offsetHeight; // Force reflow

        this.wrapperWidth = this.wrapper.clientWidth;
        this.wrapperHeight = this.wrapper.clientHeight;
        /* REPLACE START: refresh */

        this.scrollerWidth = this.scroller.offsetWidth;
        this.scrollerHeight = this.scroller.offsetHeight;
        this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
        this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
        /* REPLACE END: refresh */

        this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
        this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

        if (!this.hasHorizontalScroll) {
          this.maxScrollX = 0;
          this.scrollerWidth = this.wrapperWidth;
        }

        if (!this.hasVerticalScroll) {
          this.maxScrollY = 0;
          this.scrollerHeight = this.wrapperHeight;
        }

        this.endTime = 0;
        this.directionX = 0;
        this.directionY = 0;
        this.wrapperOffset = utils.offset(this.wrapper);

        this._execEvent('refresh');

        this.resetPosition(); // INSERT POINT: _refresh
      },
      on: function on(type, fn) {
        if (!this._events[type]) {
          this._events[type] = [];
        }

        this._events[type].push(fn);
      },
      off: function off(type, fn) {
        if (!this._events[type]) {
          return;
        }

        var index = this._events[type].indexOf(fn);

        if (index > -1) {
          this._events[type].splice(index, 1);
        }
      },
      _execEvent: function _execEvent(type) {
        if (!this._events[type]) {
          return;
        }

        var i = 0,
            l = this._events[type].length;

        if (!l) {
          return;
        }

        for (; i < l; i++) {
          this._events[type][i].apply(this, [].slice.call(arguments, 1));
        }
      },
      scrollBy: function scrollBy(x, y, time, easing) {
        x = this.x + x;
        y = this.y + y;
        time = time || 0;
        this.scrollTo(x, y, time, easing);
      },
      scrollTo: function scrollTo(x, y, time, easing) {
        easing = easing || utils.ease.circular;
        this.isInTransition = this.options.useTransition && time > 0;
        var transitionType = this.options.useTransition && easing.style;

        if (!time || transitionType) {
          if (transitionType) {
            this._transitionTimingFunction(easing.style);

            this._transitionTime(time);
          }

          this._translate(x, y);
        } else {
          this._animate(x, y, time, easing.fn);
        }
      },
      scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
        el = el.nodeType ? el : this.scroller.querySelector(el);

        if (!el) {
          return;
        }

        var pos = utils.offset(el);
        pos.left -= this.wrapperOffset.left;
        pos.top -= this.wrapperOffset.top; // if offsetX/Y are true we center the element to the screen

        if (offsetX === true) {
          offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
        }

        if (offsetY === true) {
          offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
        }

        pos.left -= offsetX || 0;
        pos.top -= offsetY || 0;
        pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
        pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;
        time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;
        this.scrollTo(pos.left, pos.top, time, easing);
      },
      _transitionTime: function _transitionTime(time) {
        time = time || 0;
        var durationProp = utils.style.transitionDuration;
        this.scrollerStyle[durationProp] = time + 'ms';

        if (!time && utils.isBadAndroid) {
          this.scrollerStyle[durationProp] = '0.0001ms'; // remove 0.0001ms

          var self = this;
          rAF(function () {
            if (self.scrollerStyle[durationProp] === '0.0001ms') {
              self.scrollerStyle[durationProp] = '0s';
            }
          });
        }

        if (this.indicators) {
          for (var i = this.indicators.length; i--;) {
            this.indicators[i].transitionTime(time);
          }
        } // INSERT POINT: _transitionTime

      },
      _transitionTimingFunction: function _transitionTimingFunction(easing) {
        this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

        if (this.indicators) {
          for (var i = this.indicators.length; i--;) {
            this.indicators[i].transitionTimingFunction(easing);
          }
        } // INSERT POINT: _transitionTimingFunction

      },
      _translate: function _translate(x, y) {
        if (this.options.useTransform) {
          /* REPLACE START: _translate */
          this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;
          /* REPLACE END: _translate */
        } else {
          x = Math.round(x);
          y = Math.round(y);
          this.scrollerStyle.left = x + 'px';
          this.scrollerStyle.top = y + 'px';
        }

        this.x = x;
        this.y = y;

        if (this.indicators) {
          for (var i = this.indicators.length; i--;) {
            this.indicators[i].updatePosition();
          }
        } // INSERT POINT: _translate

      },
      _initEvents: function _initEvents(remove) {
        var eventType = remove ? utils.removeEvent : utils.addEvent,
            target = this.options.bindToWrapper ? this.wrapper : window;
        eventType(window, 'orientationchange', this);
        eventType(window, 'resize', this);

        if (this.options.click) {
          eventType(this.wrapper, 'click', this, true);
        }

        if (!this.options.disableMouse) {
          eventType(this.wrapper, 'mousedown', this);
          eventType(target, 'mousemove', this);
          eventType(target, 'mousecancel', this);
          eventType(target, 'mouseup', this);
        }

        if (utils.hasPointer && !this.options.disablePointer) {
          eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
          eventType(target, utils.prefixPointerEvent('pointermove'), this);
          eventType(target, utils.prefixPointerEvent('pointercancel'), this);
          eventType(target, utils.prefixPointerEvent('pointerup'), this);
        }

        if (utils.hasTouch && !this.options.disableTouch) {
          eventType(this.wrapper, 'touchstart', this);
          eventType(target, 'touchmove', this);
          eventType(target, 'touchcancel', this);
          eventType(target, 'touchend', this);
        }

        eventType(this.scroller, 'transitionend', this);
        eventType(this.scroller, 'webkitTransitionEnd', this);
        eventType(this.scroller, 'oTransitionEnd', this);
        eventType(this.scroller, 'MSTransitionEnd', this);
      },
      getComputedPosition: function getComputedPosition() {
        var matrix = window.getComputedStyle(this.scroller, null),
            x,
            y;

        if (this.options.useTransform) {
          matrix = matrix[utils.style.transform].split(')')[0].split(', ');
          x = +(matrix[12] || matrix[4]);
          y = +(matrix[13] || matrix[5]);
        } else {
          x = +matrix.left.replace(/[^-\d.]/g, '');
          y = +matrix.top.replace(/[^-\d.]/g, '');
        }

        return {
          x: x,
          y: y
        };
      },
      _initIndicators: function _initIndicators() {
        var interactive = this.options.interactiveScrollbars,
            customStyle = typeof this.options.scrollbars != 'string',
            indicators = [],
            indicator;
        var that = this;
        this.indicators = [];

        if (this.options.scrollbars) {
          // Vertical scrollbar
          if (this.options.scrollY) {
            indicator = {
              el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
              interactive: interactive,
              defaultScrollbars: true,
              customStyle: customStyle,
              resize: this.options.resizeScrollbars,
              shrink: this.options.shrinkScrollbars,
              fade: this.options.fadeScrollbars,
              listenX: false
            };
            this.wrapper.appendChild(indicator.el);
            indicators.push(indicator);
          } // Horizontal scrollbar


          if (this.options.scrollX) {
            indicator = {
              el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
              interactive: interactive,
              defaultScrollbars: true,
              customStyle: customStyle,
              resize: this.options.resizeScrollbars,
              shrink: this.options.shrinkScrollbars,
              fade: this.options.fadeScrollbars,
              listenY: false
            };
            this.wrapper.appendChild(indicator.el);
            indicators.push(indicator);
          }
        }

        if (this.options.indicators) {
          // TODO: check concat compatibility
          indicators = indicators.concat(this.options.indicators);
        }

        for (var i = indicators.length; i--;) {
          this.indicators.push(new Indicator(this, indicators[i]));
        } // TODO: check if we can use array.map (wide compatibility and performance issues)


        function _indicatorsMap(fn) {
          if (that.indicators) {
            for (var i = that.indicators.length; i--;) {
              fn.call(that.indicators[i]);
            }
          }
        }

        if (this.options.fadeScrollbars) {
          this.on('scrollEnd', function () {
            _indicatorsMap(function () {
              this.fade();
            });
          });
          this.on('scrollCancel', function () {
            _indicatorsMap(function () {
              this.fade();
            });
          });
          this.on('scrollStart', function () {
            _indicatorsMap(function () {
              this.fade(1);
            });
          });
          this.on('beforeScrollStart', function () {
            _indicatorsMap(function () {
              this.fade(1, true);
            });
          });
        }

        this.on('refresh', function () {
          _indicatorsMap(function () {
            this.refresh();
          });
        });
        this.on('destroy', function () {
          _indicatorsMap(function () {
            this.destroy();
          });

          delete this.indicators;
        });
      },
      _initWheel: function _initWheel() {
        utils.addEvent(this.wrapper, 'wheel', this);
        utils.addEvent(this.wrapper, 'mousewheel', this);
        utils.addEvent(this.wrapper, 'DOMMouseScroll', this);
        this.on('destroy', function () {
          clearTimeout(this.wheelTimeout);
          this.wheelTimeout = null;
          utils.removeEvent(this.wrapper, 'wheel', this);
          utils.removeEvent(this.wrapper, 'mousewheel', this);
          utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
        });
      },
      _wheel: function _wheel(e) {
        if (!this.enabled) {
          return;
        }

        e.preventDefault();
        var wheelDeltaX,
            wheelDeltaY,
            newX,
            newY,
            that = this;

        if (this.wheelTimeout === undefined) {
          that._execEvent('scrollStart');
        } // Execute the scrollEnd event after 400ms the wheel stopped scrolling


        clearTimeout(this.wheelTimeout);
        this.wheelTimeout = setTimeout(function () {
          if (!that.options.snap) {
            that._execEvent('scrollEnd');
          }

          that.wheelTimeout = undefined;
        }, 400);

        if ('deltaX' in e) {
          if (e.deltaMode === 1) {
            wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
            wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
          } else {
            wheelDeltaX = -e.deltaX;
            wheelDeltaY = -e.deltaY;
          }
        } else if ('wheelDeltaX' in e) {
          wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
          wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
        } else if ('wheelDelta' in e) {
          wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
        } else if ('detail' in e) {
          wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
        } else {
          return;
        }

        wheelDeltaX *= this.options.invertWheelDirection;
        wheelDeltaY *= this.options.invertWheelDirection;

        if (!this.hasVerticalScroll) {
          wheelDeltaX = wheelDeltaY;
          wheelDeltaY = 0;
        }

        if (this.options.snap) {
          newX = this.currentPage.pageX;
          newY = this.currentPage.pageY;

          if (wheelDeltaX > 0) {
            newX--;
          } else if (wheelDeltaX < 0) {
            newX++;
          }

          if (wheelDeltaY > 0) {
            newY--;
          } else if (wheelDeltaY < 0) {
            newY++;
          }

          this.goToPage(newX, newY);
          return;
        }

        newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
        newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);
        this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
        this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

        if (newX > 0) {
          newX = 0;
        } else if (newX < this.maxScrollX) {
          newX = this.maxScrollX;
        }

        if (newY > 0) {
          newY = 0;
        } else if (newY < this.maxScrollY) {
          newY = this.maxScrollY;
        }

        this.scrollTo(newX, newY, 0); // INSERT POINT: _wheel
      },
      _initSnap: function _initSnap() {
        this.currentPage = {};

        if (typeof this.options.snap == 'string') {
          this.options.snap = this.scroller.querySelectorAll(this.options.snap);
        }

        this.on('refresh', function () {
          var i = 0,
              l,
              m = 0,
              n,
              cx,
              cy,
              x = 0,
              y,
              stepX = this.options.snapStepX || this.wrapperWidth,
              stepY = this.options.snapStepY || this.wrapperHeight,
              el;
          this.pages = [];

          if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
            return;
          }

          if (this.options.snap === true) {
            cx = Math.round(stepX / 2);
            cy = Math.round(stepY / 2);

            while (x > -this.scrollerWidth) {
              this.pages[i] = [];
              l = 0;
              y = 0;

              while (y > -this.scrollerHeight) {
                this.pages[i][l] = {
                  x: Math.max(x, this.maxScrollX),
                  y: Math.max(y, this.maxScrollY),
                  width: stepX,
                  height: stepY,
                  cx: x - cx,
                  cy: y - cy
                };
                y -= stepY;
                l++;
              }

              x -= stepX;
              i++;
            }
          } else {
            el = this.options.snap;
            l = el.length;
            n = -1;

            for (; i < l; i++) {
              if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
                m = 0;
                n++;
              }

              if (!this.pages[m]) {
                this.pages[m] = [];
              }

              x = Math.max(-el[i].offsetLeft, this.maxScrollX);
              y = Math.max(-el[i].offsetTop, this.maxScrollY);
              cx = x - Math.round(el[i].offsetWidth / 2);
              cy = y - Math.round(el[i].offsetHeight / 2);
              this.pages[m][n] = {
                x: x,
                y: y,
                width: el[i].offsetWidth,
                height: el[i].offsetHeight,
                cx: cx,
                cy: cy
              };

              if (x > this.maxScrollX) {
                m++;
              }
            }
          }

          this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0); // Update snap threshold if needed

          if (this.options.snapThreshold % 1 === 0) {
            this.snapThresholdX = this.options.snapThreshold;
            this.snapThresholdY = this.options.snapThreshold;
          } else {
            this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
            this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
          }
        });
        this.on('flick', function () {
          var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);
          this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
        });
      },
      _nearestSnap: function _nearestSnap(x, y) {
        if (!this.pages.length) {
          return {
            x: 0,
            y: 0,
            pageX: 0,
            pageY: 0
          };
        }

        var i = 0,
            l = this.pages.length,
            m = 0; // Check if we exceeded the snap threshold

        if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
          return this.currentPage;
        }

        if (x > 0) {
          x = 0;
        } else if (x < this.maxScrollX) {
          x = this.maxScrollX;
        }

        if (y > 0) {
          y = 0;
        } else if (y < this.maxScrollY) {
          y = this.maxScrollY;
        }

        for (; i < l; i++) {
          if (x >= this.pages[i][0].cx) {
            x = this.pages[i][0].x;
            break;
          }
        }

        l = this.pages[i].length;

        for (; m < l; m++) {
          if (y >= this.pages[0][m].cy) {
            y = this.pages[0][m].y;
            break;
          }
        }

        if (i == this.currentPage.pageX) {
          i += this.directionX;

          if (i < 0) {
            i = 0;
          } else if (i >= this.pages.length) {
            i = this.pages.length - 1;
          }

          x = this.pages[i][0].x;
        }

        if (m == this.currentPage.pageY) {
          m += this.directionY;

          if (m < 0) {
            m = 0;
          } else if (m >= this.pages[0].length) {
            m = this.pages[0].length - 1;
          }

          y = this.pages[0][m].y;
        }

        return {
          x: x,
          y: y,
          pageX: i,
          pageY: m
        };
      },
      goToPage: function goToPage(x, y, time, easing) {
        easing = easing || this.options.bounceEasing;

        if (x >= this.pages.length) {
          x = this.pages.length - 1;
        } else if (x < 0) {
          x = 0;
        }

        if (y >= this.pages[x].length) {
          y = this.pages[x].length - 1;
        } else if (y < 0) {
          y = 0;
        }

        var posX = this.pages[x][y].x,
            posY = this.pages[x][y].y;
        time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;
        this.currentPage = {
          x: posX,
          y: posY,
          pageX: x,
          pageY: y
        };
        this.scrollTo(posX, posY, time, easing);
      },
      next: function next(time, easing) {
        var x = this.currentPage.pageX,
            y = this.currentPage.pageY;
        x++;

        if (x >= this.pages.length && this.hasVerticalScroll) {
          x = 0;
          y++;
        }

        this.goToPage(x, y, time, easing);
      },
      prev: function prev(time, easing) {
        var x = this.currentPage.pageX,
            y = this.currentPage.pageY;
        x--;

        if (x < 0 && this.hasVerticalScroll) {
          x = 0;
          y--;
        }

        this.goToPage(x, y, time, easing);
      },
      _initKeys: function _initKeys(e) {
        // default key bindings
        var keys = {
          pageUp: 33,
          pageDown: 34,
          end: 35,
          home: 36,
          left: 37,
          up: 38,
          right: 39,
          down: 40
        };
        var i; // if you give me characters I give you keycode

        if (_typeof(this.options.keyBindings) == 'object') {
          for (i in this.options.keyBindings) {
            if (typeof this.options.keyBindings[i] == 'string') {
              this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
            }
          }
        } else {
          this.options.keyBindings = {};
        }

        for (i in keys) {
          this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
        }

        utils.addEvent(window, 'keydown', this);
        this.on('destroy', function () {
          utils.removeEvent(window, 'keydown', this);
        });
      },
      _key: function _key(e) {
        if (!this.enabled) {
          return;
        }

        var snap = this.options.snap,
            // we are using this alot, better to cache it
        newX = snap ? this.currentPage.pageX : this.x,
            newY = snap ? this.currentPage.pageY : this.y,
            now = utils.getTime(),
            prevTime = this.keyTime || 0,
            acceleration = 0.250,
            pos;

        if (this.options.useTransition && this.isInTransition) {
          pos = this.getComputedPosition();

          this._translate(Math.round(pos.x), Math.round(pos.y));

          this.isInTransition = false;
        }

        this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

        switch (e.keyCode) {
          case this.options.keyBindings.pageUp:
            if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
              newX += snap ? 1 : this.wrapperWidth;
            } else {
              newY += snap ? 1 : this.wrapperHeight;
            }

            break;

          case this.options.keyBindings.pageDown:
            if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
              newX -= snap ? 1 : this.wrapperWidth;
            } else {
              newY -= snap ? 1 : this.wrapperHeight;
            }

            break;

          case this.options.keyBindings.end:
            newX = snap ? this.pages.length - 1 : this.maxScrollX;
            newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
            break;

          case this.options.keyBindings.home:
            newX = 0;
            newY = 0;
            break;

          case this.options.keyBindings.left:
            newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
            break;

          case this.options.keyBindings.up:
            newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
            break;

          case this.options.keyBindings.right:
            newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
            break;

          case this.options.keyBindings.down:
            newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
            break;

          default:
            return;
        }

        if (snap) {
          this.goToPage(newX, newY);
          return;
        }

        if (newX > 0) {
          newX = 0;
          this.keyAcceleration = 0;
        } else if (newX < this.maxScrollX) {
          newX = this.maxScrollX;
          this.keyAcceleration = 0;
        }

        if (newY > 0) {
          newY = 0;
          this.keyAcceleration = 0;
        } else if (newY < this.maxScrollY) {
          newY = this.maxScrollY;
          this.keyAcceleration = 0;
        }

        this.scrollTo(newX, newY, 0);
        this.keyTime = now;
      },
      _animate: function _animate(destX, destY, duration, easingFn) {
        var that = this,
            startX = this.x,
            startY = this.y,
            startTime = utils.getTime(),
            destTime = startTime + duration;

        function step() {
          var now = utils.getTime(),
              newX,
              newY,
              easing;

          if (now >= destTime) {
            that.isAnimating = false;

            that._translate(destX, destY);

            if (!that.resetPosition(that.options.bounceTime)) {
              that._execEvent('scrollEnd');
            }

            return;
          }

          now = (now - startTime) / duration;
          easing = easingFn(now);
          newX = (destX - startX) * easing + startX;
          newY = (destY - startY) * easing + startY;

          that._translate(newX, newY);

          if (that.isAnimating) {
            rAF(step);
          }
        }

        this.isAnimating = true;
        step();
      },
      handleEvent: function handleEvent(e) {
        switch (e.type) {
          case 'touchstart':
          case 'pointerdown':
          case 'MSPointerDown':
          case 'mousedown':
            this._start(e);

            break;

          case 'touchmove':
          case 'pointermove':
          case 'MSPointerMove':
          case 'mousemove':
            this._move(e);

            break;

          case 'touchend':
          case 'pointerup':
          case 'MSPointerUp':
          case 'mouseup':
          case 'touchcancel':
          case 'pointercancel':
          case 'MSPointerCancel':
          case 'mousecancel':
            this._end(e);

            break;

          case 'orientationchange':
          case 'resize':
            this._resize();

            break;

          case 'transitionend':
          case 'webkitTransitionEnd':
          case 'oTransitionEnd':
          case 'MSTransitionEnd':
            this._transitionEnd(e);

            break;

          case 'wheel':
          case 'DOMMouseScroll':
          case 'mousewheel':
            this._wheel(e);

            break;

          case 'keydown':
            this._key(e);

            break;

          case 'click':
            if (this.enabled && !e._constructed) {
              e.preventDefault();
              e.stopPropagation();
            }

            break;
        }
      }
    };

    function createDefaultScrollbar(direction, interactive, type) {
      var scrollbar = document.createElement('div'),
          indicator = document.createElement('div');

      if (type === true) {
        scrollbar.style.cssText = 'position:absolute;z-index:9999';
        indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
      }

      indicator.className = 'iScrollIndicator';

      if (direction == 'h') {
        if (type === true) {
          scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
          indicator.style.height = '100%';
        }

        scrollbar.className = 'iScrollHorizontalScrollbar';
      } else {
        if (type === true) {
          scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
          indicator.style.width = '100%';
        }

        scrollbar.className = 'iScrollVerticalScrollbar';
      }

      scrollbar.style.cssText += ';overflow:hidden';

      if (!interactive) {
        scrollbar.style.pointerEvents = 'none';
      }

      scrollbar.appendChild(indicator);
      return scrollbar;
    }

    function Indicator(scroller, options) {
      this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
      this.wrapperStyle = this.wrapper.style;
      this.indicator = this.wrapper.children[0];
      this.indicatorStyle = this.indicator.style;
      this.scroller = scroller;
      this.options = {
        listenX: true,
        listenY: true,
        interactive: false,
        resize: true,
        defaultScrollbars: false,
        shrink: false,
        fade: false,
        speedRatioX: 0,
        speedRatioY: 0
      };

      for (var i in options) {
        this.options[i] = options[i];
      }

      this.sizeRatioX = 1;
      this.sizeRatioY = 1;
      this.maxPosX = 0;
      this.maxPosY = 0;

      if (this.options.interactive) {
        if (!this.options.disableTouch) {
          utils.addEvent(this.indicator, 'touchstart', this);
          utils.addEvent(window, 'touchend', this);
        }

        if (!this.options.disablePointer) {
          utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
          utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
        }

        if (!this.options.disableMouse) {
          utils.addEvent(this.indicator, 'mousedown', this);
          utils.addEvent(window, 'mouseup', this);
        }
      }

      if (this.options.fade) {
        this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
        var durationProp = utils.style.transitionDuration;
        this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms'; // remove 0.0001ms

        var self = this;

        if (utils.isBadAndroid) {
          rAF(function () {
            if (self.wrapperStyle[durationProp] === '0.0001ms') {
              self.wrapperStyle[durationProp] = '0s';
            }
          });
        }

        this.wrapperStyle.opacity = '0';
      }
    }

    Indicator.prototype = {
      handleEvent: function handleEvent(e) {
        switch (e.type) {
          case 'touchstart':
          case 'pointerdown':
          case 'MSPointerDown':
          case 'mousedown':
            this._start(e);

            break;

          case 'touchmove':
          case 'pointermove':
          case 'MSPointerMove':
          case 'mousemove':
            this._move(e);

            break;

          case 'touchend':
          case 'pointerup':
          case 'MSPointerUp':
          case 'mouseup':
          case 'touchcancel':
          case 'pointercancel':
          case 'MSPointerCancel':
          case 'mousecancel':
            this._end(e);

            break;
        }
      },
      destroy: function destroy() {
        if (this.options.fadeScrollbars) {
          clearTimeout(this.fadeTimeout);
          this.fadeTimeout = null;
        }

        if (this.options.interactive) {
          utils.removeEvent(this.indicator, 'touchstart', this);
          utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
          utils.removeEvent(this.indicator, 'mousedown', this);
          utils.removeEvent(window, 'touchmove', this);
          utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
          utils.removeEvent(window, 'mousemove', this);
          utils.removeEvent(window, 'touchend', this);
          utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
          utils.removeEvent(window, 'mouseup', this);
        }

        if (this.options.defaultScrollbars) {
          this.wrapper.parentNode.removeChild(this.wrapper);
        }
      },
      _start: function _start(e) {
        var point = e.touches ? e.touches[0] : e;
        e.preventDefault();
        e.stopPropagation();
        this.transitionTime();
        this.initiated = true;
        this.moved = false;
        this.lastPointX = point.pageX;
        this.lastPointY = point.pageY;
        this.startTime = utils.getTime();

        if (!this.options.disableTouch) {
          utils.addEvent(window, 'touchmove', this);
        }

        if (!this.options.disablePointer) {
          utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
        }

        if (!this.options.disableMouse) {
          utils.addEvent(window, 'mousemove', this);
        }

        this.scroller._execEvent('beforeScrollStart');
      },
      _move: function _move(e) {
        var point = e.touches ? e.touches[0] : e,
            deltaX,
            deltaY,
            newX,
            newY,
            timestamp = utils.getTime();

        if (!this.moved) {
          this.scroller._execEvent('scrollStart');
        }

        this.moved = true;
        deltaX = point.pageX - this.lastPointX;
        this.lastPointX = point.pageX;
        deltaY = point.pageY - this.lastPointY;
        this.lastPointY = point.pageY;
        newX = this.x + deltaX;
        newY = this.y + deltaY;

        this._pos(newX, newY); // INSERT POINT: indicator._move


        e.preventDefault();
        e.stopPropagation();
      },
      _end: function _end(e) {
        if (!this.initiated) {
          return;
        }

        this.initiated = false;
        e.preventDefault();
        e.stopPropagation();
        utils.removeEvent(window, 'touchmove', this);
        utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
        utils.removeEvent(window, 'mousemove', this);

        if (this.scroller.options.snap) {
          var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

          var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

          if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
            this.scroller.directionX = 0;
            this.scroller.directionY = 0;
            this.scroller.currentPage = snap;
            this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
          }
        }

        if (this.moved) {
          this.scroller._execEvent('scrollEnd');
        }
      },
      transitionTime: function transitionTime(time) {
        time = time || 0;
        var durationProp = utils.style.transitionDuration;
        this.indicatorStyle[durationProp] = time + 'ms';

        if (!time && utils.isBadAndroid) {
          this.indicatorStyle[durationProp] = '0.0001ms'; // remove 0.0001ms

          var self = this;
          rAF(function () {
            if (self.indicatorStyle[durationProp] === '0.0001ms') {
              self.indicatorStyle[durationProp] = '0s';
            }
          });
        }
      },
      transitionTimingFunction: function transitionTimingFunction(easing) {
        this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
      },
      refresh: function refresh() {
        this.transitionTime();

        if (this.options.listenX && !this.options.listenY) {
          this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
        } else if (this.options.listenY && !this.options.listenX) {
          this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
        } else {
          this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
        }

        if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
          utils.addClass(this.wrapper, 'iScrollBothScrollbars');
          utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

          if (this.options.defaultScrollbars && this.options.customStyle) {
            if (this.options.listenX) {
              this.wrapper.style.right = '8px';
            } else {
              this.wrapper.style.bottom = '8px';
            }
          }
        } else {
          utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
          utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

          if (this.options.defaultScrollbars && this.options.customStyle) {
            if (this.options.listenX) {
              this.wrapper.style.right = '2px';
            } else {
              this.wrapper.style.bottom = '2px';
            }
          }
        }

        var r = this.wrapper.offsetHeight; // force refresh

        if (this.options.listenX) {
          this.wrapperWidth = this.wrapper.clientWidth;

          if (this.options.resize) {
            this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
            this.indicatorStyle.width = this.indicatorWidth + 'px';
          } else {
            this.indicatorWidth = this.indicator.clientWidth;
          }

          this.maxPosX = this.wrapperWidth - this.indicatorWidth;

          if (this.options.shrink == 'clip') {
            this.minBoundaryX = -this.indicatorWidth + 8;
            this.maxBoundaryX = this.wrapperWidth - 8;
          } else {
            this.minBoundaryX = 0;
            this.maxBoundaryX = this.maxPosX;
          }

          this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
        }

        if (this.options.listenY) {
          this.wrapperHeight = this.wrapper.clientHeight;

          if (this.options.resize) {
            this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
            this.indicatorStyle.height = this.indicatorHeight + 'px';
          } else {
            this.indicatorHeight = this.indicator.clientHeight;
          }

          this.maxPosY = this.wrapperHeight - this.indicatorHeight;

          if (this.options.shrink == 'clip') {
            this.minBoundaryY = -this.indicatorHeight + 8;
            this.maxBoundaryY = this.wrapperHeight - 8;
          } else {
            this.minBoundaryY = 0;
            this.maxBoundaryY = this.maxPosY;
          }

          this.maxPosY = this.wrapperHeight - this.indicatorHeight;
          this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
        }

        this.updatePosition();
      },
      updatePosition: function updatePosition() {
        var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
            y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

        if (!this.options.ignoreBoundaries) {
          if (x < this.minBoundaryX) {
            if (this.options.shrink == 'scale') {
              this.width = Math.max(this.indicatorWidth + x, 8);
              this.indicatorStyle.width = this.width + 'px';
            }

            x = this.minBoundaryX;
          } else if (x > this.maxBoundaryX) {
            if (this.options.shrink == 'scale') {
              this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
              this.indicatorStyle.width = this.width + 'px';
              x = this.maxPosX + this.indicatorWidth - this.width;
            } else {
              x = this.maxBoundaryX;
            }
          } else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
            this.width = this.indicatorWidth;
            this.indicatorStyle.width = this.width + 'px';
          }

          if (y < this.minBoundaryY) {
            if (this.options.shrink == 'scale') {
              this.height = Math.max(this.indicatorHeight + y * 3, 8);
              this.indicatorStyle.height = this.height + 'px';
            }

            y = this.minBoundaryY;
          } else if (y > this.maxBoundaryY) {
            if (this.options.shrink == 'scale') {
              this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
              this.indicatorStyle.height = this.height + 'px';
              y = this.maxPosY + this.indicatorHeight - this.height;
            } else {
              y = this.maxBoundaryY;
            }
          } else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
            this.height = this.indicatorHeight;
            this.indicatorStyle.height = this.height + 'px';
          }
        }

        this.x = x;
        this.y = y;

        if (this.scroller.options.useTransform) {
          this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
        } else {
          this.indicatorStyle.left = x + 'px';
          this.indicatorStyle.top = y + 'px';
        }
      },
      _pos: function _pos(x, y) {
        if (x < 0) {
          x = 0;
        } else if (x > this.maxPosX) {
          x = this.maxPosX;
        }

        if (y < 0) {
          y = 0;
        } else if (y > this.maxPosY) {
          y = this.maxPosY;
        }

        x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
        y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;
        this.scroller.scrollTo(x, y);
      },
      fade: function fade(val, hold) {
        if (hold && !this.visible) {
          return;
        }

        clearTimeout(this.fadeTimeout);
        this.fadeTimeout = null;
        var time = val ? 250 : 500,
            delay = val ? 0 : 300;
        val = val ? '1' : '0';
        this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';
        this.fadeTimeout = setTimeout(function (val) {
          this.wrapperStyle.opacity = val;
          this.visible = +val;
        }.bind(this, val), delay);
      }
    };
    IScroll.utils = utils;

    if ( true && module.exports) {
      module.exports = IScroll;
    } else if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return IScroll;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(window, document, Math);
});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  !function (e, t) {
    if ("object" == ( false ? undefined : _typeof(exports)) && "object" == ( false ? undefined : _typeof(module))) module.exports = t();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var r, n; }
  }(void 0, function () {
    return function (e) {
      function t(r) {
        if (n[r]) return n[r].exports;
        var i = n[r] = {
          exports: {},
          id: r,
          loaded: !1
        };
        return e[r].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports;
      }

      var n = {};
      return t.m = e, t.c = n, t.p = "", t(0);
    }([function (e, t, n) {
      n(6), n(7), e.exports = n(8);
    }, function (e, t, n) {
      (function (t) {
        !function (n) {
          function r(e, t) {
            return function () {
              e.apply(t, arguments);
            };
          }

          function i(e) {
            if ("object" != _typeof(this)) throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof e) throw new TypeError("not a function");
            this._state = null, this._value = null, this._deferreds = [], l(e, r(a, this), r(s, this));
          }

          function o(e) {
            var t = this;
            return null === this._state ? void this._deferreds.push(e) : void f(function () {
              var n = t._state ? e.onFulfilled : e.onRejected;
              if (null === n) return void (t._state ? e.resolve : e.reject)(t._value);
              var r;

              try {
                r = n(t._value);
              } catch (i) {
                return void e.reject(i);
              }

              e.resolve(r);
            });
          }

          function a(e) {
            try {
              if (e === this) throw new TypeError("A promise cannot be resolved with itself.");

              if (e && ("object" == _typeof(e) || "function" == typeof e)) {
                var t = e.then;
                if ("function" == typeof t) return void l(r(t, e), r(a, this), r(s, this));
              }

              this._state = !0, this._value = e, u.call(this);
            } catch (n) {
              s.call(this, n);
            }
          }

          function s(e) {
            this._state = !1, this._value = e, u.call(this);
          }

          function u() {
            for (var e = 0, t = this._deferreds.length; t > e; e++) {
              o.call(this, this._deferreds[e]);
            }

            this._deferreds = null;
          }

          function c(e, t, n, r) {
            this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.resolve = n, this.reject = r;
          }

          function l(e, t, n) {
            var r = !1;

            try {
              e(function (e) {
                r || (r = !0, t(e));
              }, function (e) {
                r || (r = !0, n(e));
              });
            } catch (i) {
              if (r) return;
              r = !0, n(i);
            }
          }

          var f = "function" == typeof t && t || function (e) {
            setTimeout(e, 1);
          },
              d = Array.isArray || function (e) {
            return "[object Array]" === Object.prototype.toString.call(e);
          };

          i.prototype["catch"] = function (e) {
            return this.then(null, e);
          }, i.prototype.then = function (e, t) {
            var n = this;
            return new i(function (r, i) {
              o.call(n, new c(e, t, r, i));
            });
          }, i.all = function () {
            var e = Array.prototype.slice.call(1 === arguments.length && d(arguments[0]) ? arguments[0] : arguments);
            return new i(function (t, n) {
              function r(o, a) {
                try {
                  if (a && ("object" == _typeof(a) || "function" == typeof a)) {
                    var s = a.then;
                    if ("function" == typeof s) return void s.call(a, function (e) {
                      r(o, e);
                    }, n);
                  }

                  e[o] = a, 0 === --i && t(e);
                } catch (u) {
                  n(u);
                }
              }

              if (0 === e.length) return t([]);

              for (var i = e.length, o = 0; o < e.length; o++) {
                r(o, e[o]);
              }
            });
          }, i.resolve = function (e) {
            return e && "object" == _typeof(e) && e.constructor === i ? e : new i(function (t) {
              t(e);
            });
          }, i.reject = function (e) {
            return new i(function (t, n) {
              n(e);
            });
          }, i.race = function (e) {
            return new i(function (t, n) {
              for (var r = 0, i = e.length; i > r; r++) {
                e[r].then(t, n);
              }
            });
          }, i._setImmediateFn = function (e) {
            f = e;
          }, i.prototype.always = function (e) {
            var t = this.constructor;
            return this.then(function (n) {
              return t.resolve(e()).then(function () {
                return n;
              });
            }, function (n) {
              return t.resolve(e()).then(function () {
                throw n;
              });
            });
          }, "undefined" != typeof e && e.exports ? e.exports = i : n.Promise || (n.Promise = i);
        }(this);
      }).call(t, n(2).setImmediate);
    }, function (e, t, n) {
      (function (e, r) {
        function i(e, t) {
          this._id = e, this._clearFn = t;
        }

        var o = n(3).nextTick,
            a = Function.prototype.apply,
            s = Array.prototype.slice,
            u = {},
            c = 0;
        t.setTimeout = function () {
          return new i(a.call(setTimeout, window, arguments), clearTimeout);
        }, t.setInterval = function () {
          return new i(a.call(setInterval, window, arguments), clearInterval);
        }, t.clearTimeout = t.clearInterval = function (e) {
          e.close();
        }, i.prototype.unref = i.prototype.ref = function () {}, i.prototype.close = function () {
          this._clearFn.call(window, this._id);
        }, t.enroll = function (e, t) {
          clearTimeout(e._idleTimeoutId), e._idleTimeout = t;
        }, t.unenroll = function (e) {
          clearTimeout(e._idleTimeoutId), e._idleTimeout = -1;
        }, t._unrefActive = t.active = function (e) {
          clearTimeout(e._idleTimeoutId);
          var t = e._idleTimeout;
          t >= 0 && (e._idleTimeoutId = setTimeout(function () {
            e._onTimeout && e._onTimeout();
          }, t));
        }, t.setImmediate = "function" == typeof e ? e : function (e) {
          var n = c++,
              r = arguments.length < 2 ? !1 : s.call(arguments, 1);
          return u[n] = !0, o(function () {
            u[n] && (r ? e.apply(null, r) : e.call(null), t.clearImmediate(n));
          }), n;
        }, t.clearImmediate = "function" == typeof r ? r : function (e) {
          delete u[e];
        };
      }).call(t, n(2).setImmediate, n(2).clearImmediate);
    }, function (e, t) {
      function n() {
        c = !1, a.length ? u = a.concat(u) : l = -1, u.length && r();
      }

      function r() {
        if (!c) {
          var e = setTimeout(n);
          c = !0;

          for (var t = u.length; t;) {
            for (a = u, u = []; ++l < t;) {
              a && a[l].run();
            }

            l = -1, t = u.length;
          }

          a = null, c = !1, clearTimeout(e);
        }
      }

      function i(e, t) {
        this.fun = e, this.array = t;
      }

      function o() {}

      var a,
          s = e.exports = {},
          u = [],
          c = !1,
          l = -1;
      s.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) {
          t[n - 1] = arguments[n];
        }
        u.push(new i(e, t)), 1 !== u.length || c || setTimeout(r, 0);
      }, i.prototype.run = function () {
        this.fun.apply(null, this.array);
      }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = o, s.addListener = o, s.once = o, s.off = o, s.removeListener = o, s.removeAllListeners = o, s.emit = o, s.binding = function (e) {
        throw new Error("process.binding is not supported");
      }, s.cwd = function () {
        return "/";
      }, s.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }, s.umask = function () {
        return 0;
      };
    }, function (e, t) {
      function n() {
        var e = ~navigator.userAgent.indexOf("Android") && ~navigator.vendor.indexOf("Google") && !~navigator.userAgent.indexOf("Chrome");
        return e && navigator.userAgent.match(/AppleWebKit\/(\d+)/).pop() <= 534 || /MQQBrowser/g.test(navigator.userAgent);
      }

      var r = function () {
        try {
          return new Blob(), !0;
        } catch (e) {
          return !1;
        }
      }() ? window.Blob : function (e, t) {
        var n = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder || window.MozBlobBuilder)();
        return e.forEach(function (e) {
          n.append(e);
        }), n.getBlob(t ? t.type : void 0);
      },
          i = function () {
        function e() {
          var e = this,
              n = [],
              i = Array(21).join("-") + (+new Date() * (1e16 * Math.random())).toString(36),
              o = XMLHttpRequest.prototype.send;
          this.getParts = function () {
            return n.toString();
          }, this.append = function (e, t, r) {
            n.push("--" + i + '\r\nContent-Disposition: form-data; name="' + e + '"'), t instanceof Blob ? (n.push('; filename="' + (r || "blob") + '"\r\nContent-Type: ' + t.type + "\r\n\r\n"), n.push(t)) : n.push("\r\n\r\n" + t), n.push("\r\n");
          }, t++, XMLHttpRequest.prototype.send = function (a) {
            var s,
                u,
                c = this;
            a === e ? (n.push("--" + i + "--\r\n"), u = new r(n), s = new FileReader(), s.onload = function () {
              o.call(c, s.result);
            }, s.onerror = function (e) {
              throw e;
            }, s.readAsArrayBuffer(u), this.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + i), t--, 0 == t && (XMLHttpRequest.prototype.send = o)) : o.call(this, a);
          };
        }

        var t = 0;
        return e.prototype = Object.create(FormData.prototype), e;
      }();

      e.exports = {
        Blob: r,
        FormData: n() ? i : FormData
      };
    }, function (e, t, n) {
      var r, i;
      (function () {
        function n(e) {
          return !!e.exifdata;
        }

        function o(e, t) {
          t = t || e.match(/^data\:([^\;]+)\;base64,/im)[1] || "", e = e.replace(/^data\:([^\;]+)\;base64,/gim, "");

          for (var n = atob(e), r = n.length, i = new ArrayBuffer(r), o = new Uint8Array(i), a = 0; r > a; a++) {
            o[a] = n.charCodeAt(a);
          }

          return i;
        }

        function a(e, t) {
          var n = new XMLHttpRequest();
          n.open("GET", e, !0), n.responseType = "blob", n.onload = function (e) {
            (200 == this.status || 0 === this.status) && t(this.response);
          }, n.send();
        }

        function s(e, t) {
          function n(n) {
            var r = u(n),
                i = c(n);
            e.exifdata = r || {}, e.iptcdata = i || {}, t && t.call(e);
          }

          if (e.src) {
            if (/^data\:/i.test(e.src)) {
              var r = o(e.src);
              n(r);
            } else if (/^blob\:/i.test(e.src)) {
              var i = new FileReader();
              i.onload = function (e) {
                n(e.target.result);
              }, a(e.src, function (e) {
                i.readAsArrayBuffer(e);
              });
            } else {
              var s = new XMLHttpRequest();
              s.onload = function () {
                200 == this.status || 0 === this.status ? n(s.response) : t(new Error("Could not load image")), s = null;
              }, s.open("GET", e.src, !0), s.responseType = "arraybuffer", s.send(null);
            }
          } else if (window.FileReader && (e instanceof window.Blob || e instanceof window.File)) {
            var i = new FileReader();
            i.onload = function (e) {
              p && console.log("Got file of length " + e.target.result.byteLength), n(e.target.result);
            }, i.readAsArrayBuffer(e);
          }
        }

        function u(e) {
          var t = new DataView(e);
          if (p && console.log("Got file of length " + e.byteLength), 255 != t.getUint8(0) || 216 != t.getUint8(1)) return p && console.log("Not a valid JPEG"), !1;

          for (var n, r = 2, i = e.byteLength; i > r;) {
            if (255 != t.getUint8(r)) return p && console.log("Not a valid marker at offset " + r + ", found: " + t.getUint8(r)), !1;
            if (n = t.getUint8(r + 1), p && console.log(n), 225 == n) return p && console.log("Found 0xFFE1 marker"), g(t, r + 4, t.getUint16(r + 2) - 2);
            r += 2 + t.getUint16(r + 2);
          }
        }

        function c(e) {
          var t = new DataView(e);
          if (p && console.log("Got file of length " + e.byteLength), 255 != t.getUint8(0) || 216 != t.getUint8(1)) return p && console.log("Not a valid JPEG"), !1;

          for (var n = 2, r = e.byteLength, i = function i(e, t) {
            return 56 === e.getUint8(t) && 66 === e.getUint8(t + 1) && 73 === e.getUint8(t + 2) && 77 === e.getUint8(t + 3) && 4 === e.getUint8(t + 4) && 4 === e.getUint8(t + 5);
          }; r > n;) {
            if (i(t, n)) {
              var o = t.getUint8(n + 7);
              o % 2 !== 0 && (o += 1), 0 === o && (o = 4);
              var a = n + 8 + o,
                  s = t.getUint16(n + 6 + o);
              return l(e, a, s);
            }

            n++;
          }
        }

        function l(e, t, n) {
          for (var r, i, o, a, s, u = new DataView(e), c = {}, l = t; t + n > l;) {
            28 === u.getUint8(l) && 2 === u.getUint8(l + 1) && (a = u.getUint8(l + 2), a in S && (o = u.getInt16(l + 3), s = o + 5, i = S[a], r = h(u, l + 5, o), c.hasOwnProperty(i) ? c[i] instanceof Array ? c[i].push(r) : c[i] = [c[i], r] : c[i] = r)), l++;
          }

          return c;
        }

        function f(e, t, n, r, i) {
          var o,
              a,
              s,
              u = e.getUint16(n, !i),
              c = {};

          for (s = 0; u > s; s++) {
            o = n + 12 * s + 2, a = r[e.getUint16(o, !i)], !a && p && console.log("Unknown tag: " + e.getUint16(o, !i)), c[a] = d(e, o, t, n, i);
          }

          return c;
        }

        function d(e, t, n, r, i) {
          var o,
              a,
              s,
              u,
              c,
              l,
              f = e.getUint16(t + 2, !i),
              d = e.getUint32(t + 4, !i),
              g = e.getUint32(t + 8, !i) + n;

          switch (f) {
            case 1:
            case 7:
              if (1 == d) return e.getUint8(t + 8, !i);

              for (o = d > 4 ? g : t + 8, a = [], u = 0; d > u; u++) {
                a[u] = e.getUint8(o + u);
              }

              return a;

            case 2:
              return o = d > 4 ? g : t + 8, h(e, o, d - 1);

            case 3:
              if (1 == d) return e.getUint16(t + 8, !i);

              for (o = d > 2 ? g : t + 8, a = [], u = 0; d > u; u++) {
                a[u] = e.getUint16(o + 2 * u, !i);
              }

              return a;

            case 4:
              if (1 == d) return e.getUint32(t + 8, !i);

              for (a = [], u = 0; d > u; u++) {
                a[u] = e.getUint32(g + 4 * u, !i);
              }

              return a;

            case 5:
              if (1 == d) return c = e.getUint32(g, !i), l = e.getUint32(g + 4, !i), s = new Number(c / l), s.numerator = c, s.denominator = l, s;

              for (a = [], u = 0; d > u; u++) {
                c = e.getUint32(g + 8 * u, !i), l = e.getUint32(g + 4 + 8 * u, !i), a[u] = new Number(c / l), a[u].numerator = c, a[u].denominator = l;
              }

              return a;

            case 9:
              if (1 == d) return e.getInt32(t + 8, !i);

              for (a = [], u = 0; d > u; u++) {
                a[u] = e.getInt32(g + 4 * u, !i);
              }

              return a;

            case 10:
              if (1 == d) return e.getInt32(g, !i) / e.getInt32(g + 4, !i);

              for (a = [], u = 0; d > u; u++) {
                a[u] = e.getInt32(g + 8 * u, !i) / e.getInt32(g + 4 + 8 * u, !i);
              }

              return a;
          }
        }

        function h(e, t, n) {
          var r,
              i = "";

          for (r = t; t + n > r; r++) {
            i += String.fromCharCode(e.getUint8(r));
          }

          return i;
        }

        function g(e, t) {
          if ("Exif" != h(e, t, 4)) return p && console.log("Not valid EXIF data! " + h(e, t, 4)), !1;
          var n,
              r,
              i,
              o,
              a,
              s = t + 6;
          if (18761 == e.getUint16(s)) n = !1;else {
            if (19789 != e.getUint16(s)) return p && console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)"), !1;
            n = !0;
          }
          if (42 != e.getUint16(s + 2, !n)) return p && console.log("Not valid TIFF data! (no 0x002A)"), !1;
          var u = e.getUint32(s + 4, !n);
          if (8 > u) return p && console.log("Not valid TIFF data! (First offset less than 8)", e.getUint32(s + 4, !n)), !1;

          if (r = f(e, s, s + u, v, n), r.ExifIFDPointer) {
            o = f(e, s, s + r.ExifIFDPointer, w, n);

            for (i in o) {
              switch (i) {
                case "LightSource":
                case "Flash":
                case "MeteringMode":
                case "ExposureProgram":
                case "SensingMethod":
                case "SceneCaptureType":
                case "SceneType":
                case "CustomRendered":
                case "WhiteBalance":
                case "GainControl":
                case "Contrast":
                case "Saturation":
                case "Sharpness":
                case "SubjectDistanceRange":
                case "FileSource":
                  o[i] = b[i][o[i]];
                  break;

                case "ExifVersion":
                case "FlashpixVersion":
                  o[i] = String.fromCharCode(o[i][0], o[i][1], o[i][2], o[i][3]);
                  break;

                case "ComponentsConfiguration":
                  o[i] = b.Components[o[i][0]] + b.Components[o[i][1]] + b.Components[o[i][2]] + b.Components[o[i][3]];
              }

              r[i] = o[i];
            }
          }

          if (r.GPSInfoIFDPointer) {
            a = f(e, s, s + r.GPSInfoIFDPointer, y, n);

            for (i in a) {
              switch (i) {
                case "GPSVersionID":
                  a[i] = a[i][0] + "." + a[i][1] + "." + a[i][2] + "." + a[i][3];
              }

              r[i] = a[i];
            }
          }

          return r;
        }

        var p = !1,
            m = function m(e) {
          return e instanceof m ? e : this instanceof m ? void (this.EXIFwrapped = e) : new m(e);
        };

        "undefined" != typeof e && e.exports && (t = e.exports = m), t.EXIF = m;
        var w = m.Tags = {
          36864: "ExifVersion",
          40960: "FlashpixVersion",
          40961: "ColorSpace",
          40962: "PixelXDimension",
          40963: "PixelYDimension",
          37121: "ComponentsConfiguration",
          37122: "CompressedBitsPerPixel",
          37500: "MakerNote",
          37510: "UserComment",
          40964: "RelatedSoundFile",
          36867: "DateTimeOriginal",
          36868: "DateTimeDigitized",
          37520: "SubsecTime",
          37521: "SubsecTimeOriginal",
          37522: "SubsecTimeDigitized",
          33434: "ExposureTime",
          33437: "FNumber",
          34850: "ExposureProgram",
          34852: "SpectralSensitivity",
          34855: "ISOSpeedRatings",
          34856: "OECF",
          37377: "ShutterSpeedValue",
          37378: "ApertureValue",
          37379: "BrightnessValue",
          37380: "ExposureBias",
          37381: "MaxApertureValue",
          37382: "SubjectDistance",
          37383: "MeteringMode",
          37384: "LightSource",
          37385: "Flash",
          37396: "SubjectArea",
          37386: "FocalLength",
          41483: "FlashEnergy",
          41484: "SpatialFrequencyResponse",
          41486: "FocalPlaneXResolution",
          41487: "FocalPlaneYResolution",
          41488: "FocalPlaneResolutionUnit",
          41492: "SubjectLocation",
          41493: "ExposureIndex",
          41495: "SensingMethod",
          41728: "FileSource",
          41729: "SceneType",
          41730: "CFAPattern",
          41985: "CustomRendered",
          41986: "ExposureMode",
          41987: "WhiteBalance",
          41988: "DigitalZoomRation",
          41989: "FocalLengthIn35mmFilm",
          41990: "SceneCaptureType",
          41991: "GainControl",
          41992: "Contrast",
          41993: "Saturation",
          41994: "Sharpness",
          41995: "DeviceSettingDescription",
          41996: "SubjectDistanceRange",
          40965: "InteroperabilityIFDPointer",
          42016: "ImageUniqueID"
        },
            v = m.TiffTags = {
          256: "ImageWidth",
          257: "ImageHeight",
          34665: "ExifIFDPointer",
          34853: "GPSInfoIFDPointer",
          40965: "InteroperabilityIFDPointer",
          258: "BitsPerSample",
          259: "Compression",
          262: "PhotometricInterpretation",
          274: "Orientation",
          277: "SamplesPerPixel",
          284: "PlanarConfiguration",
          530: "YCbCrSubSampling",
          531: "YCbCrPositioning",
          282: "XResolution",
          283: "YResolution",
          296: "ResolutionUnit",
          273: "StripOffsets",
          278: "RowsPerStrip",
          279: "StripByteCounts",
          513: "JPEGInterchangeFormat",
          514: "JPEGInterchangeFormatLength",
          301: "TransferFunction",
          318: "WhitePoint",
          319: "PrimaryChromaticities",
          529: "YCbCrCoefficients",
          532: "ReferenceBlackWhite",
          306: "DateTime",
          270: "ImageDescription",
          271: "Make",
          272: "Model",
          305: "Software",
          315: "Artist",
          33432: "Copyright"
        },
            y = m.GPSTags = {
          0: "GPSVersionID",
          1: "GPSLatitudeRef",
          2: "GPSLatitude",
          3: "GPSLongitudeRef",
          4: "GPSLongitude",
          5: "GPSAltitudeRef",
          6: "GPSAltitude",
          7: "GPSTimeStamp",
          8: "GPSSatellites",
          9: "GPSStatus",
          10: "GPSMeasureMode",
          11: "GPSDOP",
          12: "GPSSpeedRef",
          13: "GPSSpeed",
          14: "GPSTrackRef",
          15: "GPSTrack",
          16: "GPSImgDirectionRef",
          17: "GPSImgDirection",
          18: "GPSMapDatum",
          19: "GPSDestLatitudeRef",
          20: "GPSDestLatitude",
          21: "GPSDestLongitudeRef",
          22: "GPSDestLongitude",
          23: "GPSDestBearingRef",
          24: "GPSDestBearing",
          25: "GPSDestDistanceRef",
          26: "GPSDestDistance",
          27: "GPSProcessingMethod",
          28: "GPSAreaInformation",
          29: "GPSDateStamp",
          30: "GPSDifferential"
        },
            b = m.StringValues = {
          ExposureProgram: {
            0: "Not defined",
            1: "Manual",
            2: "Normal program",
            3: "Aperture priority",
            4: "Shutter priority",
            5: "Creative program",
            6: "Action program",
            7: "Portrait mode",
            8: "Landscape mode"
          },
          MeteringMode: {
            0: "Unknown",
            1: "Average",
            2: "CenterWeightedAverage",
            3: "Spot",
            4: "MultiSpot",
            5: "Pattern",
            6: "Partial",
            255: "Other"
          },
          LightSource: {
            0: "Unknown",
            1: "Daylight",
            2: "Fluorescent",
            3: "Tungsten (incandescent light)",
            4: "Flash",
            9: "Fine weather",
            10: "Cloudy weather",
            11: "Shade",
            12: "Daylight fluorescent (D 5700 - 7100K)",
            13: "Day white fluorescent (N 4600 - 5400K)",
            14: "Cool white fluorescent (W 3900 - 4500K)",
            15: "White fluorescent (WW 3200 - 3700K)",
            17: "Standard light A",
            18: "Standard light B",
            19: "Standard light C",
            20: "D55",
            21: "D65",
            22: "D75",
            23: "D50",
            24: "ISO studio tungsten",
            255: "Other"
          },
          Flash: {
            0: "Flash did not fire",
            1: "Flash fired",
            5: "Strobe return light not detected",
            7: "Strobe return light detected",
            9: "Flash fired, compulsory flash mode",
            13: "Flash fired, compulsory flash mode, return light not detected",
            15: "Flash fired, compulsory flash mode, return light detected",
            16: "Flash did not fire, compulsory flash mode",
            24: "Flash did not fire, auto mode",
            25: "Flash fired, auto mode",
            29: "Flash fired, auto mode, return light not detected",
            31: "Flash fired, auto mode, return light detected",
            32: "No flash function",
            65: "Flash fired, red-eye reduction mode",
            69: "Flash fired, red-eye reduction mode, return light not detected",
            71: "Flash fired, red-eye reduction mode, return light detected",
            73: "Flash fired, compulsory flash mode, red-eye reduction mode",
            77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
            79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
            89: "Flash fired, auto mode, red-eye reduction mode",
            93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",
            95: "Flash fired, auto mode, return light detected, red-eye reduction mode"
          },
          SensingMethod: {
            1: "Not defined",
            2: "One-chip color area sensor",
            3: "Two-chip color area sensor",
            4: "Three-chip color area sensor",
            5: "Color sequential area sensor",
            7: "Trilinear sensor",
            8: "Color sequential linear sensor"
          },
          SceneCaptureType: {
            0: "Standard",
            1: "Landscape",
            2: "Portrait",
            3: "Night scene"
          },
          SceneType: {
            1: "Directly photographed"
          },
          CustomRendered: {
            0: "Normal process",
            1: "Custom process"
          },
          WhiteBalance: {
            0: "Auto white balance",
            1: "Manual white balance"
          },
          GainControl: {
            0: "None",
            1: "Low gain up",
            2: "High gain up",
            3: "Low gain down",
            4: "High gain down"
          },
          Contrast: {
            0: "Normal",
            1: "Soft",
            2: "Hard"
          },
          Saturation: {
            0: "Normal",
            1: "Low saturation",
            2: "High saturation"
          },
          Sharpness: {
            0: "Normal",
            1: "Soft",
            2: "Hard"
          },
          SubjectDistanceRange: {
            0: "Unknown",
            1: "Macro",
            2: "Close view",
            3: "Distant view"
          },
          FileSource: {
            3: "DSC"
          },
          Components: {
            0: "",
            1: "Y",
            2: "Cb",
            3: "Cr",
            4: "R",
            5: "G",
            6: "B"
          }
        },
            S = {
          120: "caption",
          110: "credit",
          25: "keywords",
          55: "dateCreated",
          80: "byline",
          85: "bylineTitle",
          122: "captionWriter",
          105: "headline",
          116: "copyright",
          15: "category"
        };
        m.getData = function (e, t) {
          return (e instanceof Image || e instanceof HTMLImageElement) && !e.complete ? !1 : (n(e) ? t && t.call(e) : s(e, t), !0);
        }, m.getTag = function (e, t) {
          return n(e) ? e.exifdata[t] : void 0;
        }, m.getAllTags = function (e) {
          if (!n(e)) return {};
          var t,
              r = e.exifdata,
              i = {};

          for (t in r) {
            r.hasOwnProperty(t) && (i[t] = r[t]);
          }

          return i;
        }, m.pretty = function (e) {
          if (!n(e)) return "";
          var t,
              r = e.exifdata,
              i = "";

          for (t in r) {
            r.hasOwnProperty(t) && (i += "object" == _typeof(r[t]) ? r[t] instanceof Number ? t + " : " + r[t] + " [" + r[t].numerator + "/" + r[t].denominator + "]\r\n" : t + " : [" + r[t].length + " values]\r\n" : t + " : " + r[t] + "\r\n");
          }

          return i;
        }, m.readFromBinaryFile = function (e) {
          return u(e);
        }, r = [], i = function () {
          return m;
        }.apply(t, r), !(void 0 !== i && (e.exports = i));
      }).call(this);
    }, function (e, t, n) {
      var r, i;
      !function () {
        function n(e) {
          var t = e.naturalWidth,
              n = e.naturalHeight;

          if (t * n > 1048576) {
            var r = document.createElement("canvas");
            r.width = r.height = 1;
            var i = r.getContext("2d");
            return i.drawImage(e, -t + 1, 0), 0 === i.getImageData(0, 0, 1, 1).data[3];
          }

          return !1;
        }

        function o(e, t, n) {
          var r = document.createElement("canvas");
          r.width = 1, r.height = n;
          var i = r.getContext("2d");
          i.drawImage(e, 0, 0);

          for (var o = i.getImageData(0, 0, 1, n).data, a = 0, s = n, u = n; u > a;) {
            var c = o[4 * (u - 1) + 3];
            0 === c ? s = u : a = u, u = s + a >> 1;
          }

          var l = u / n;
          return 0 === l ? 1 : l;
        }

        function a(e, t, n) {
          var r = document.createElement("canvas");
          return s(e, r, t, n), r.toDataURL("image/jpeg", t.quality || .8);
        }

        function s(e, t, r, i) {
          var a = e.naturalWidth,
              s = e.naturalHeight,
              c = r.width,
              l = r.height,
              f = t.getContext("2d");
          f.save(), u(t, f, c, l, r.orientation);
          var d = n(e);
          d && (a /= 2, s /= 2);
          var h = 1024,
              g = document.createElement("canvas");
          g.width = g.height = h;

          for (var p = g.getContext("2d"), m = i ? o(e, a, s) : 1, w = Math.ceil(h * c / a), v = Math.ceil(h * l / s / m), y = 0, b = 0; s > y;) {
            for (var S = 0, I = 0; a > S;) {
              p.clearRect(0, 0, h, h), p.drawImage(e, -S, -y), f.drawImage(g, 0, 0, h, h, I, b, w, v), S += h, I += w;
            }

            y += h, b += v;
          }

          f.restore(), g = p = null;
        }

        function u(e, t, n, r, i) {
          switch (i) {
            case 5:
            case 6:
            case 7:
            case 8:
              e.width = r, e.height = n;
              break;

            default:
              e.width = n, e.height = r;
          }

          switch (i) {
            case 2:
              t.translate(n, 0), t.scale(-1, 1);
              break;

            case 3:
              t.translate(n, r), t.rotate(Math.PI);
              break;

            case 4:
              t.translate(0, r), t.scale(1, -1);
              break;

            case 5:
              t.rotate(.5 * Math.PI), t.scale(1, -1);
              break;

            case 6:
              t.rotate(.5 * Math.PI), t.translate(0, -r);
              break;

            case 7:
              t.rotate(.5 * Math.PI), t.translate(n, -r), t.scale(-1, 1);
              break;

            case 8:
              t.rotate(-.5 * Math.PI), t.translate(-n, 0);
          }
        }

        function c(e) {
          if (window.Blob && e instanceof Blob) {
            var t = new Image(),
                n = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;
            if (!n) throw Error("No createObjectURL function found to create blob url");
            t.src = n.createObjectURL(e), this.blob = e, e = t;
          }

          if (!e.naturalWidth && !e.naturalHeight) {
            var r = this;
            e.onload = function () {
              var e = r.imageLoadListeners;

              if (e) {
                r.imageLoadListeners = null;

                for (var t = 0, n = e.length; n > t; t++) {
                  e[t]();
                }
              }
            }, this.imageLoadListeners = [];
          }

          this.srcImage = e;
        }

        c.prototype.render = function (e, t, n) {
          if (this.imageLoadListeners) {
            var r = this;
            return void this.imageLoadListeners.push(function () {
              r.render(e, t, n);
            });
          }

          t = t || {};
          var i = this.srcImage,
              o = i.src,
              u = o.length,
              c = i.naturalWidth,
              l = i.naturalHeight,
              f = t.width,
              d = t.height,
              h = t.maxWidth,
              g = t.maxHeight,
              p = this.blob && "image/jpeg" === this.blob.type || 0 === o.indexOf("data:image/jpeg") || o.indexOf(".jpg") === u - 4 || o.indexOf(".jpeg") === u - 5;
          f && !d ? d = l * f / c << 0 : d && !f ? f = c * d / l << 0 : (f = c, d = l), h && f > h && (f = h, d = l * f / c << 0), g && d > g && (d = g, f = c * d / l << 0);
          var m = {
            width: f,
            height: d
          };

          for (var w in t) {
            m[w] = t[w];
          }

          var v = e.tagName.toLowerCase();
          "img" === v ? e.src = a(this.srcImage, m, p) : "canvas" === v && s(this.srcImage, e, m, p), "function" == typeof this.onrender && this.onrender(e), n && n();
        }, r = [], i = function () {
          return c;
        }.apply(t, r), !(void 0 !== i && (e.exports = i));
      }();
    }, function (e, t) {
      function n(e) {
        function t(e) {
          for (var t = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], n = 0; 64 > n; n++) {
            var r = F((t[n] * e + 50) / 100);
            1 > r ? r = 1 : r > 255 && (r = 255), D[N[n]] = r;
          }

          for (var i = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], o = 0; 64 > o; o++) {
            var a = F((i[o] * e + 50) / 100);
            1 > a ? a = 1 : a > 255 && (a = 255), x[N[o]] = a;
          }

          for (var s = [1, 1.387039845, 1.306562965, 1.175875602, 1, .785694958, .5411961, .275899379], u = 0, c = 0; 8 > c; c++) {
            for (var l = 0; 8 > l; l++) {
              U[u] = 1 / (D[N[u]] * s[c] * s[l] * 8), C[u] = 1 / (x[N[u]] * s[c] * s[l] * 8), u++;
            }
          }
        }

        function n(e, t) {
          for (var n = 0, r = 0, i = new Array(), o = 1; 16 >= o; o++) {
            for (var a = 1; a <= e[o]; a++) {
              i[t[r]] = [], i[t[r]][0] = n, i[t[r]][1] = o, r++, n++;
            }

            n *= 2;
          }

          return i;
        }

        function r() {
          y = n(W, H), b = n(V, X), S = n(z, q), I = n(Q, Y);
        }

        function i() {
          for (var e = 1, t = 2, n = 1; 15 >= n; n++) {
            for (var r = e; t > r; r++) {
              A[32767 + r] = n, T[32767 + r] = [], T[32767 + r][1] = n, T[32767 + r][0] = r;
            }

            for (var i = -(t - 1); -e >= i; i++) {
              A[32767 + i] = n, T[32767 + i] = [], T[32767 + i][1] = n, T[32767 + i][0] = t - 1 + i;
            }

            e <<= 1, t <<= 1;
          }
        }

        function o() {
          for (var e = 0; 256 > e; e++) {
            k[e] = 19595 * e, k[e + 256 >> 0] = 38470 * e, k[e + 512 >> 0] = 7471 * e + 32768, k[e + 768 >> 0] = -11059 * e, k[e + 1024 >> 0] = -21709 * e, k[e + 1280 >> 0] = 32768 * e + 8421375, k[e + 1536 >> 0] = -27439 * e, k[e + 1792 >> 0] = -5329 * e;
          }
        }

        function a(e) {
          for (var t = e[0], n = e[1] - 1; n >= 0;) {
            t & 1 << n && (G |= 1 << O), n--, O--, 0 > O && (255 == G ? (s(255), s(0)) : s(G), O = 7, G = 0);
          }
        }

        function s(e) {
          M.push(j[e]);
        }

        function u(e) {
          s(e >> 8 & 255), s(255 & e);
        }

        function c(e, t) {
          var n,
              r,
              i,
              o,
              a,
              s,
              u,
              c,
              l,
              f = 0;
          var d = 8,
              h = 64;

          for (l = 0; d > l; ++l) {
            n = e[f], r = e[f + 1], i = e[f + 2], o = e[f + 3], a = e[f + 4], s = e[f + 5], u = e[f + 6], c = e[f + 7];
            var g = n + c,
                p = n - c,
                m = r + u,
                w = r - u,
                v = i + s,
                y = i - s,
                b = o + a,
                S = o - a,
                I = g + b,
                P = g - b,
                F = m + v,
                D = m - v;
            e[f] = I + F, e[f + 4] = I - F;
            var x = .707106781 * (D + P);
            e[f + 2] = P + x, e[f + 6] = P - x, I = S + y, F = y + w, D = w + p;
            var U = .382683433 * (I - D),
                C = .5411961 * I + U,
                T = 1.306562965 * D + U,
                A = .707106781 * F,
                R = p + A,
                M = p - A;
            e[f + 5] = M + C, e[f + 3] = M - C, e[f + 1] = R + T, e[f + 7] = R - T, f += 8;
          }

          for (f = 0, l = 0; d > l; ++l) {
            n = e[f], r = e[f + 8], i = e[f + 16], o = e[f + 24], a = e[f + 32], s = e[f + 40], u = e[f + 48], c = e[f + 56];

            var G = n + c,
                O = n - c,
                _ = r + u,
                B = r - u,
                E = i + s,
                j = i - s,
                k = o + a,
                N = o - a,
                W = G + k,
                H = G - k,
                z = _ + E,
                q = _ - E;

            e[f] = W + z, e[f + 32] = W - z;
            var V = .707106781 * (q + H);
            e[f + 16] = H + V, e[f + 48] = H - V, W = N + j, z = j + B, q = B + O;
            var X = .382683433 * (W - q),
                Q = .5411961 * W + X,
                Y = 1.306562965 * q + X,
                K = .707106781 * z,
                J = O + K,
                Z = O - K;
            e[f + 40] = Z + Q, e[f + 24] = Z - Q, e[f + 8] = J + Y, e[f + 56] = J - Y, f++;
          }

          var $;

          for (l = 0; h > l; ++l) {
            $ = e[l] * t[l], L[l] = $ > 0 ? $ + .5 | 0 : $ - .5 | 0;
          }

          return L;
        }

        function l() {
          u(65504), u(16), s(74), s(70), s(73), s(70), s(0), s(1), s(1), s(0), u(1), u(1), s(0), s(0);
        }

        function f(e, t) {
          u(65472), u(17), s(8), u(t), u(e), s(3), s(1), s(17), s(0), s(2), s(17), s(1), s(3), s(17), s(1);
        }

        function d() {
          u(65499), u(132), s(0);

          for (var e = 0; 64 > e; e++) {
            s(D[e]);
          }

          s(1);

          for (var t = 0; 64 > t; t++) {
            s(x[t]);
          }
        }

        function h() {
          u(65476), u(418), s(0);

          for (var e = 0; 16 > e; e++) {
            s(W[e + 1]);
          }

          for (var t = 0; 11 >= t; t++) {
            s(H[t]);
          }

          s(16);

          for (var n = 0; 16 > n; n++) {
            s(z[n + 1]);
          }

          for (var r = 0; 161 >= r; r++) {
            s(q[r]);
          }

          s(1);

          for (var i = 0; 16 > i; i++) {
            s(V[i + 1]);
          }

          for (var o = 0; 11 >= o; o++) {
            s(X[o]);
          }

          s(17);

          for (var a = 0; 16 > a; a++) {
            s(Q[a + 1]);
          }

          for (var c = 0; 161 >= c; c++) {
            s(Y[c]);
          }
        }

        function g() {
          u(65498), u(12), s(3), s(1), s(0), s(2), s(17), s(3), s(17), s(0), s(63), s(0);
        }

        function p(e, t, n, r, i) {
          var o,
              s = i[0],
              u = i[240];
          var l = 16,
              f = 63,
              d = 64;

          for (var h = c(e, t), g = 0; d > g; ++g) {
            R[N[g]] = h[g];
          }

          var p = R[0] - n;
          n = R[0], 0 == p ? a(r[0]) : (o = 32767 + p, a(r[A[o]]), a(T[o]));

          for (var m = 63; m > 0 && 0 == R[m]; m--) {
            ;
          }

          if (0 == m) return a(s), n;

          for (var w, v = 1; m >= v;) {
            for (var y = v; 0 == R[v] && m >= v; ++v) {
              ;
            }

            var b = v - y;

            if (b >= l) {
              w = b >> 4;

              for (var S = 1; w >= S; ++S) {
                a(u);
              }

              b = 15 & b;
            }

            o = 32767 + R[v], a(i[(b << 4) + A[o]]), a(T[o]), v++;
          }

          return m != f && a(s), n;
        }

        function m() {
          for (var e = String.fromCharCode, t = 0; 256 > t; t++) {
            j[t] = e(t);
          }
        }

        function w(e) {
          if (0 >= e && (e = 1), e > 100 && (e = 100), P != e) {
            var n = 0;
            n = 50 > e ? Math.floor(5e3 / e) : Math.floor(200 - 2 * e), t(n), P = e;
          }
        }

        function v() {
          var t = new Date().getTime();
          e || (e = 50), m(), r(), i(), o(), w(e);
          new Date().getTime() - t;
        }

        var y,
            b,
            S,
            I,
            P,
            F = (Math.round, Math.floor),
            D = new Array(64),
            x = new Array(64),
            U = new Array(64),
            C = new Array(64),
            T = new Array(65535),
            A = new Array(65535),
            L = new Array(64),
            R = new Array(64),
            M = [],
            G = 0,
            O = 7,
            _ = new Array(64),
            B = new Array(64),
            E = new Array(64),
            j = new Array(256),
            k = new Array(2048),
            N = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63],
            W = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            H = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            z = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125],
            q = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250],
            V = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            X = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            Q = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119],
            Y = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];

        this.encode = function (e, t, n) {
          var r = new Date().getTime();
          t && w(t), M = new Array(), G = 0, O = 7, u(65496), l(), d(), f(e.width, e.height), h(), g();
          var i = 0,
              o = 0,
              s = 0;
          G = 0, O = 7, this.encode.displayName = "_encode_";

          for (var c, m, v, P, F, D, x, T, A, L = e.data, R = e.width, j = e.height, N = 4 * R, W = 0; j > W;) {
            for (c = 0; N > c;) {
              for (F = N * W + c, D = F, x = -1, T = 0, A = 0; 64 > A; A++) {
                T = A >> 3, x = 4 * (7 & A), D = F + T * N + x, W + T >= j && (D -= N * (W + 1 + T - j)), c + x >= N && (D -= c + x - N + 4), m = L[D++], v = L[D++], P = L[D++], _[A] = (k[m] + k[v + 256 >> 0] + k[P + 512 >> 0] >> 16) - 128, B[A] = (k[m + 768 >> 0] + k[v + 1024 >> 0] + k[P + 1280 >> 0] >> 16) - 128, E[A] = (k[m + 1280 >> 0] + k[v + 1536 >> 0] + k[P + 1792 >> 0] >> 16) - 128;
              }

              i = p(_, U, i, y, S), o = p(B, C, o, b, I), s = p(E, C, s, b, I), c += 32;
            }

            W += 8;
          }

          if (O >= 0) {
            var H = [];
            H[1] = O + 1, H[0] = (1 << O + 1) - 1, a(H);
          }

          if (u(65497), n) {
            for (var z = M.length, q = new Uint8Array(z), V = 0; z > V; V++) {
              q[V] = M[V].charCodeAt();
            }

            M = [];
            new Date().getTime() - r;
            return q;
          }

          var X = "data:image/jpeg;base64," + btoa(M.join(""));
          M = [];
          new Date().getTime() - r;
          return X;
        }, v();
      }

      e.exports = n;
    }, function (e, t, n) {
      function r(e, t) {
        var n = this;
        if (!e) throw new Error("没有收到图片，可能的解决方案：https://github.com/think2011/localResizeIMG/issues/7");
        t = t || {}, n.defaults = {
          width: null,
          height: null,
          fieldName: "file",
          quality: .7
        }, n.file = e;

        for (var r in t) {
          t.hasOwnProperty(r) && (n.defaults[r] = t[r]);
        }

        return this.init();
      }

      function i(e) {
        var t = null;
        return t = e ? [].filter.call(document.scripts, function (t) {
          return -1 !== t.src.indexOf(e);
        })[0] : document.scripts[document.scripts.length - 1], t ? t.src.substr(0, t.src.lastIndexOf("/")) : null;
      }

      function o(e) {
        var t;
        t = e.split(",")[0].indexOf("base64") >= 0 ? atob(e.split(",")[1]) : unescape(e.split(",")[1]);

        for (var n = e.split(",")[0].split(":")[1].split(";")[0], r = new Uint8Array(t.length), i = 0; i < t.length; i++) {
          r[i] = t.charCodeAt(i);
        }

        return new s.Blob([r.buffer], {
          type: n
        });
      }

      n.p = i("lrz") + "/", window.URL = window.URL || window.webkitURL;

      var a = n(1),
          s = n(4),
          u = n(5),
          c = function (e) {
        var t = /OS (\d)_.* like Mac OS X/g.exec(e),
            n = /Android (\d.*?);/g.exec(e) || /Android\/(\d.*?) /g.exec(e);
        return {
          oldIOS: t ? +t.pop() < 8 : !1,
          oldAndroid: n ? +n.pop().substr(0, 3) < 4.5 : !1,
          iOS: /\(i[^;]+;( U;)? CPU.+Mac OS X/.test(e),
          android: /Android/g.test(e),
          mQQBrowser: /MQQBrowser/g.test(e)
        };
      }(navigator.userAgent);

      r.prototype.init = function () {
        var e = this,
            t = e.file,
            n = "string" == typeof t,
            r = /^data:/.test(t),
            i = new Image(),
            u = document.createElement("canvas"),
            c = n ? t : URL.createObjectURL(t);
        if (e.img = i, e.blob = c, e.canvas = u, n ? e.fileName = r ? "base64.jpg" : t.split("/").pop() : e.fileName = t.name, !document.createElement("canvas").getContext) throw new Error("浏览器不支持canvas");
        return new a(function (n, a) {
          i.onerror = function () {
            var e = new Error("加载图片文件失败");
            throw a(e), e;
          }, i.onload = function () {
            e._getBase64().then(function (e) {
              if (e.length < 10) {
                var t = new Error("生成base64失败");
                throw a(t), t;
              }

              return e;
            }).then(function (r) {
              var i = null;
              "object" == _typeof(e.file) && r.length > e.file.size ? (i = new FormData(), t = e.file) : (i = new s.FormData(), t = o(r)), i.append(e.defaults.fieldName, t, e.fileName.replace(/\..+/g, ".jpg")), n({
                formData: i,
                fileLen: +t.size,
                base64: r,
                base64Len: r.length,
                origin: e.file,
                file: t
              });

              for (var a in e) {
                e.hasOwnProperty(a) && (e[a] = null);
              }

              URL.revokeObjectURL(e.blob);
            });
          }, !r && (i.crossOrigin = "*"), i.src = c;
        });
      }, r.prototype._getBase64 = function () {
        var e = this,
            t = e.img,
            n = e.file,
            r = e.canvas;
        return new a(function (i) {
          try {
            u.getData("object" == _typeof(n) ? n : t, function () {
              e.orientation = u.getTag(this, "Orientation"), e.resize = e._getResize(), e.ctx = r.getContext("2d"), r.width = e.resize.width, r.height = e.resize.height, e.ctx.fillStyle = "#fff", e.ctx.fillRect(0, 0, r.width, r.height), c.oldIOS ? e._createBase64ForOldIOS().then(i) : e._createBase64().then(i);
            });
          } catch (o) {
            throw new Error(o);
          }
        });
      }, r.prototype._createBase64ForOldIOS = function () {
        var e = this,
            t = e.img,
            r = e.canvas,
            i = e.defaults,
            o = e.orientation;
        return new a(function (e) {
          !function () {
            var a = [n(6)];
            (function (n) {
              var a = new n(t);
              "5678".indexOf(o) > -1 ? a.render(r, {
                width: r.height,
                height: r.width,
                orientation: o
              }) : a.render(r, {
                width: r.width,
                height: r.height,
                orientation: o
              }), e(r.toDataURL("image/jpeg", i.quality));
            }).apply(null, a);
          }();
        });
      }, r.prototype._createBase64 = function () {
        var e = this,
            t = e.resize,
            r = e.img,
            i = e.canvas,
            o = e.ctx,
            s = e.defaults,
            u = e.orientation;

        switch (u) {
          case 3:
            o.rotate(180 * Math.PI / 180), o.drawImage(r, -t.width, -t.height, t.width, t.height);
            break;

          case 6:
            o.rotate(90 * Math.PI / 180), o.drawImage(r, 0, -t.width, t.height, t.width);
            break;

          case 8:
            o.rotate(270 * Math.PI / 180), o.drawImage(r, -t.height, 0, t.height, t.width);
            break;

          case 2:
            o.translate(t.width, 0), o.scale(-1, 1), o.drawImage(r, 0, 0, t.width, t.height);
            break;

          case 4:
            o.translate(t.width, 0), o.scale(-1, 1), o.rotate(180 * Math.PI / 180), o.drawImage(r, -t.width, -t.height, t.width, t.height);
            break;

          case 5:
            o.translate(t.width, 0), o.scale(-1, 1), o.rotate(90 * Math.PI / 180), o.drawImage(r, 0, -t.width, t.height, t.width);
            break;

          case 7:
            o.translate(t.width, 0), o.scale(-1, 1), o.rotate(270 * Math.PI / 180), o.drawImage(r, -t.height, 0, t.height, t.width);
            break;

          default:
            o.drawImage(r, 0, 0, t.width, t.height);
        }

        return new a(function (e) {
          c.oldAndroid || c.mQQBrowser || !navigator.userAgent ? !function () {
            var t = [n(7)];
            (function (t) {
              var n = new t(),
                  r = o.getImageData(0, 0, i.width, i.height);
              e(n.encode(r, 100 * s.quality));
            }).apply(null, t);
          }() : e(i.toDataURL("image/jpeg", s.quality));
        });
      }, r.prototype._getResize = function () {
        var e = this,
            t = e.img,
            n = e.defaults,
            r = n.width,
            i = n.height,
            o = e.orientation,
            a = {
          width: t.width,
          height: t.height
        };
        if ("5678".indexOf(o) > -1 && (a.width = t.height, a.height = t.width), a.width < r || a.height < i) return a;
        var s = a.width / a.height;

        for (r && i ? s >= r / i ? a.width > r && (a.width = r, a.height = Math.ceil(r / s)) : a.height > i && (a.height = i, a.width = Math.ceil(i * s)) : r ? r < a.width && (a.width = r, a.height = Math.ceil(r / s)) : i && i < a.height && (a.width = Math.ceil(i * s), a.height = i); a.width >= 3264 || a.height >= 2448;) {
          a.width *= .8, a.height *= .8;
        }

        return a;
      }, window.lrz = function (e, t) {
        return new r(e, t);
      }, window.lrz.version = "4.9.40", e.exports = window.lrz;
    }]);
  });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)(module)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  module.exports = function (module) {
    if (!module.webpackPolyfill) {
      module.deprecate = function () {};

      module.paths = []; // module.parent = undefined by default

      if (!module.children) module.children = [];
      Object.defineProperty(module, "loaded", {
        enumerable: true,
        get: function get() {
          return module.l;
        }
      });
      Object.defineProperty(module, "id", {
        enumerable: true,
        get: function get() {
          return module.i;
        }
      });
      module.webpackPolyfill = 1;
    }

    return module;
  };
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  var defaultDisplayMap = {};
  module.exports = {
    getType: function getType(v) {
      return Object.prototype.toString.call('').slice(8, -1);
    },
    isObject: function isObject(v) {
      return _typeof(v) === 'object';
    },
    isNumber: function isNumber(v) {
      return typeof v === 'number';
    },
    isArray: function isArray(v) {
      return Array.isArray(v);
    },
    isBoolean: function isBoolean(v) {
      return typeof v === 'boolean';
    },
    isFunction: function isFunction(v) {
      return typeof v === 'function';
    },
    isPercent: function isPercent(v) {
      return /%$/.test(v + '');
    },
    isPlainObject: function isPlainObject(v) {
      return this.getType(v === 'Object');
    },
    //类数组转数组
    toArray: function toArray(v) {
      return Array.prototype.map.call(v, function (n) {
        return n;
      });
    },
    bind: function bind(context) {
      for (var _len = arguments.length, methods = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        methods[_key - 1] = arguments[_key];
      }

      methods.forEach(function (method) {
        context[method] = context[method].bind(context);
      });
    },
    destroy: function destroy(context) {
      Object.getOwnPropertyNames(context).forEach(function (prop) {
        delete context[prop];
      });
      context.__proto__ = Object.prototype;
    },
    extend: function (_extend) {
      function extend() {
        return _extend.apply(this, arguments);
      }

      extend.toString = function () {
        return _extend.toString();
      };

      return extend;
    }(function () {
      var isArray = this.isArray;
      var isObject = this.isObject;
      var isBoolean = this.isBoolean;
      var isFunction = this.isFunction;
      var isPlainObject = this.isPlainObject;
      var options,
          name,
          src,
          copy,
          copyIsArray,
          target = arguments[0] || {},
          toString = Object.prototype.toString,
          i = 1,
          length = arguments.length,
          deep = false; // 处理深拷贝

      if (isBoolean(target)) {
        deep = target; // Skip the boolean and the target

        target = arguments[i] || {};
        i++;
      } // Handle case when target is a string or something (possible in deep copy)


      if (!isObject(target) && !isFunction(target)) {
        target = {};
      } // 如果没有合并的对象，则表示 target 为合并对象，将 target 合并给当前函数的持有者


      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name]; // 防止死循环

            if (target === copy) {
              continue;
            } // 深拷贝对象或者数组


            if (deep && copy && ((copyIsArray = isArray(copy)) || isPlainObject(copy))) {
              if (copyIsArray) {
                copyIsArray = false;
                src = src && isArray(src) ? src : [];
              } else {
                src = src && isPlainObject(src) ? src : {};
              }

              target[name] = extend(deep, src, copy);
            } else if (copy !== undefined) {
              // 仅忽略未定义的值
              target[name] = copy;
            }
          }
        }
      } // Return the modified object


      return target;
    }),
    createElement: function createElement(parentNode, className, id, prop) {
      var elem = document.createElement('DIV');

      if (_typeof(className) === 'object') {
        prop = className;
        className = null;
      }

      if (_typeof(id) === 'object') {
        prop = id;
        id = null;
      }

      if (_typeof(prop) === 'object') {
        for (var p in prop) {
          elem.style[p] = prop[p];
        }
      }

      if (className) elem.className = className;
      if (id) elem.id = id;
      parentNode.appendChild(elem);
      return elem;
    },
    removeElement: function removeElement(elem) {
      elem.parentNode && elem.parentNode.removeChild(elem);
    },

    /**
     * 让隐藏元素正确执行程序（IE9及以上浏览器）
     * @param elems  {DOM|Array} DOM元素或者DOM元素组成的数组
     * @param func   {Function}  需要执行的程序函数
     * @param target {Object}    执行程序时函数中 this 的指向
     */
    hideAction: function hideAction(elems, func, target) {
      if (_typeof(elems) !== 'object') {
        elems = [];
      }

      if (typeof elems.length === 'undefined') {
        elems = [elems];
      }

      var hideElems = [],
          hideElemsDisplay = [];

      for (var i = 0, elem; elem = elems[i++];) {
        while (elem instanceof HTMLElement) {
          var nodeName = elem.nodeName;

          if (!elem.getClientRects().length) {
            hideElems.push(elem);
            hideElemsDisplay.push(elem.style.display);
            var display = defaultDisplayMap[nodeName];

            if (!display) {
              var temp = document.createElement(nodeName);
              document.body.appendChild(temp);
              display = window.getComputedStyle(temp).display;
              temp.parentNode.removeChild(temp);
              if (display === 'none') display = 'block';
              defaultDisplayMap[nodeName] = display;
            }

            elem.style.display = display;
          }

          if (nodeName === 'BODY') break;
          elem = elem.parentNode;
        }
      }

      if (typeof func === 'function') func.call(target || this);
      var l = hideElems.length;

      while (l--) {
        hideElems.pop().style.display = hideElemsDisplay.pop();
      }
    },
    // 返回指定属性在当前浏览器中的兼容前缀
    // 如果无需兼容前缀，则返回一个空字符串
    // all 是一个布尔值，如果为 true，则会返回包含前缀的属性名
    support: function support(prop, all) {
      var returnProp = all ? prop : '';
      var testElem = document.documentElement;
      if (prop in testElem.style) return returnProp;
      var testProp = prop.charAt(0).toUpperCase() + prop.substr(1),
          prefixs = ['Webkit', 'Moz', 'ms', 'O'];

      for (var i = 0, prefix; prefix = prefixs[i++];) {
        if (prefix + testProp in testElem.style) {
          return '-' + prefix.toLowerCase() + '-' + returnProp;
        }
      }

      return returnProp;
    },
    attr: function attr(elem, prop, value) {
      if (_typeof(prop) === 'object') {
        for (var p in prop) {
          elem[p] = prop[p];
        }

        return elem;
      }

      if (value === undefined) {
        return elem[prop];
      } else {
        elem[prop] = value;
        return elem;
      }
    },
    css: function css(elem, prop, value) {
      var isObject = this.isObject;
      var isNumber = this.isNumber;
      var cssNumber = {
        'animationIterationCount': true,
        'columnCount': true,
        'fillOpacity': true,
        'flexGrow': true,
        'flexShrink': true,
        'fontWeight': true,
        'lineHeight': true,
        'opacity': true,
        'order': true,
        'orphans': true,
        'widows': true,
        'zIndex': true,
        'zoom': true
      };

      if (isObject(prop)) {
        for (var p in prop) {
          value = prop[p];
          if (isNumber(value) && !cssNumber[prop]) value += 'px';
          elem.style[p] = value;
        }

        return elem;
      }

      if (value === undefined) {
        return window.getComputedStyle(elem)[prop];
      } else {
        if (isNumber(value) && !cssNumber[prop]) value += 'px';
        elem.style[prop] = value;
        return elem;
      }
    },
    $: function $(selector, context) {
      var toArray = this.toArray;

      if (selector instanceof HTMLElement) {
        return [selector];
      } else if (_typeof(selector) === 'object' && selector.length) {
        return toArray(selector);
      } else if (!selector || typeof selector !== 'string') {
        return [];
      }

      if (typeof context === 'string') {
        context = document.querySelector(context);
      }

      if (!(context instanceof HTMLElement)) {
        context = document;
      }

      return toArray(context.querySelectorAll(selector));
    },
    getScale: function getScale(w1, h1, w2, h2) {
      var sx = w1 / w2;
      var sy = h1 / h2;
      return sx > sy ? sx : sy;
    },
    pointRotate: function pointRotate(point, angle) {
      var radian = angleToRadian(angle),
          sin = Math.sin(radian),
          cos = Math.cos(radian);
      return {
        x: cos * point.x - sin * point.y,
        y: cos * point.y + sin * point.x
      };
    },
    angleToRadian: function angleToRadian(angle) {
      return angle / 180 * Math.PI;
    },
    loaclToLoacl: function loaclToLoacl(layerOne, layerTwo, x, y) {
      var hideAction = this.hideAction;
      x = x || 0;
      y = y || 0;
      var layerOneRect, layerTwoRect;
      hideAction([layerOne, layerTwo], function () {
        layerOneRect = layerOne.getBoundingClientRect();
        layerTwoRect = layerTwo.getBoundingClientRect();
      });
      return {
        x: layerTwoRect.left - layerOneRect.left + x,
        y: layerTwoRect.top - layerOneRect.top + y
      };
    },
    globalToLoacl: function globalToLoacl(layer, x, y) {
      var hideAction = this.hideAction;
      x = x || 0;
      y = y || 0;
      var layerRect;
      hideAction(layer, function () {
        layerRect = layer.getBoundingClientRect();
      });
      return {
        x: x - layerRect.left,
        y: y - layerRect.top
      };
    }
  };
});

/***/ })
/******/ ])["default"];
});